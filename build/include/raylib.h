/**********************************************************************************************
*
*   raylib v5.5 - A simple and easy-to-use library to enjoy videogames programming (www.raylib.com)
*
*   FEATURES:
*       - NO external dependencies, all required libraries included with raylib
*       - Multiplatform: Windows, Linux, FreeBSD, OpenBSD, NetBSD, DragonFly,
*                        MacOS, Haiku, Android, Raspberry Pi, DRM native, HTML5.
*       - Written in plain C code (C99) in PascalCase/camelCase notation
*       - Hardware accelerated with OpenGL (1.1, 2.1, 3.3, 4.3, ES2, ES3 - choose at compile)
*       - Unique OpenGL abstraction layer (usable as standalone module): [rlgl]
*       - Multiple Fonts formats supported (TTF, OTF, FNT, BDF, Sprite fonts)
*       - Outstanding texture formats support, including compressed formats (DXT, ETC, ASTC)
*       - Full 3d support for 3d Shapes, Models, Billboards, Heightmaps and more!
*       - Flexible Materials system, supporting classic maps and PBR maps
*       - Animated 3D models supported (skeletal bones animation) (IQM, M3D, GLTF)
*       - Shaders support, including Model shaders and Postprocessing shaders
*       - Powerful math module for Vector, Matrix and Quaternion operations: [raymath]
*       - Audio loading and playing with streaming support (WAV, OGG, MP3, FLAC, QOA, XM, MOD)
*       - VR stereo rendering with configurable HMD device parameters
*       - Bindings to multiple programming languages available!
*
*   NOTES:
*       - One default Font is loaded on InitWindow()->LoadFontDefault() [core, text]
*       - One default Texture2D is loaded on rlglInit(), 1x1 white pixel R8G8B8A8 [rlgl] (OpenGL 3.3 or ES2)
*       - One default Shader is loaded on rlglInit()->rlLoadShaderDefault() [rlgl] (OpenGL 3.3 or ES2)
*       - One default RenderBatch is loaded on rlglInit()->rlLoadRenderBatch() [rlgl] (OpenGL 3.3 or ES2)
*
*   DEPENDENCIES (included):
*       [rcore][GLFW] rglfw (Camilla LÃ¶wy - github.com/glfw/glfw) for window/context management and input
*       [rcore][RGFW] rgfw (ColleagueRiley - github.com/ColleagueRiley/RGFW) for window/context management and input
*       [rlgl] glad/glad_gles2 (David Herberth - github.com/Dav1dde/glad) for OpenGL 3.3 extensions loading
*       [raudio] miniaudio (David Reid - github.com/mackron/miniaudio) for audio device/context management
*
*   OPTIONAL DEPENDENCIES (included):
*       [rcore] msf_gif (Miles Fogle) for GIF recording
*       [rcore] sinfl (Micha Mettke) for DEFLATE decompression algorithm
*       [rcore] sdefl (Micha Mettke) for DEFLATE compression algorithm
*       [rcore] rprand (Ramon Snatamaria) for pseudo-random numbers generation
*       [rtextures] qoi (Dominic Szablewski - https://phoboslab.org) for QOI image manage
*       [rtextures] stb_image (Sean Barret) for images loading (BMP, TGA, PNG, JPEG, HDR...)
*       [rtextures] stb_image_write (Sean Barret) for image writing (BMP, TGA, PNG, JPG)
*       [rtextures] stb_image_resize2 (Sean Barret) for image resizing algorithms
*       [rtextures] stb_perlin (Sean Barret) for Perlin Noise image generation
*       [rtext] stb_truetype (Sean Barret) for ttf fonts loading
*       [rtext] stb_rect_pack (Sean Barret) for rectangles packing
*       [rmodels] par_shapes (Philip Rideout) for parametric 3d shapes generation
*       [rmodels] tinyobj_loader_c (Syoyo Fujita) for models loading (OBJ, MTL)
*       [rmodels] cgltf (Johannes Kuhlmann) for models loading (glTF)
*       [rmodels] m3d (bzt) for models loading (M3D, https://bztsrc.gitlab.io/model3d)
*       [rmodels] vox_loader (Johann Nadalutti) for models loading (VOX)
*       [raudio] dr_wav (David Reid) for WAV audio file loading
*       [raudio] dr_flac (David Reid) for FLAC audio file loading
*       [raudio] dr_mp3 (David Reid) for MP3 audio file loading
*       [raudio] stb_vorbis (Sean Barret) for OGG audio loading
*       [raudio] jar_xm (Joshua Reisenauer) for XM audio module loading
*       [raudio] jar_mod (Joshua Reisenauer) for MOD audio module loading
*       [raudio] qoa (Dominic Szablewski - https://phoboslab.org) for QOA audio manage
*
*
*   LICENSE: zlib/libpng
*
*   raylib is licensed under an unmodified zlib/libpng license, which is an OSI-certified,
*   BSD-like license that allows static linking with closed source software:
*
*   Copyright (c) 2013-2024 Ramon Santamaria (@raysan5)
*
*   This software is provided "as-is", without any express or implied warranty. In no event
*   will the authors be held liable for any damages arising from the use of this software.
*
*   Permission is granted to anyone to use this software for any purpose, including commercial
*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
*
*     1. The origin of this software must not be misrepresented; you must not claim that you
*     wrote the original software. If you use this software in a product, an acknowledgment
*     in the product documentation would be appreciated but is not required.
*
*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
*     as being the original software.
*
*     3. This notice may not be removed or altered from any source distribution.
*
**********************************************************************************************/

#ifndef RAYLIB_H
#define RAYLIB_H

#include <stdarg.h>     // Required for: va_list - Only used by TraceLogCallback

#define RAYLIB_VERSION_MAJOR 5
#define RAYLIB_VERSION_MINOR 5
#define RAYLIB_VERSION_PATCH 0
#define RAYLIB_VERSION  "5.5"

// Function specifiers in case library is build/used as a shared library
// NOTE: Microsoft specifiers to tell compiler that symbols are imported/exported from a .dll
// NOTE: visibility("default") attribute makes symbols "visible" when compiled with -fvisibility=hidden
#if defined(_WIN32)
    #if defined(__TINYC__)
        #define __declspec(x) __attribute__((x))
    #endif
    #if defined(BUILD_LIBTYPE_SHARED)
        #define RLAPI __declspec(dllexport)     // We are building the library as a Win32 shared library (.dll)
    #elif defined(USE_LIBTYPE_SHARED)
        #define RLAPI __declspec(dllimport)     // We are using the library as a Win32 shared library (.dll)
    #endif
#else
    #if defined(BUILD_LIBTYPE_SHARED)
        #define RLAPI __attribute__((visibility("default"))) // We are building as a Unix shared library (.so/.dylib)
    #endif
#endif

#ifndef RLAPI
    #define RLAPI       // Functions defined as 'extern' by default (implicit specifiers)
#endif

//----------------------------------------------------------------------------------
// Some basic Defines
//----------------------------------------------------------------------------------
#ifndef PI
    #define PI 3.14159265358979323846f
#endif
#ifndef DEG2RAD
    #define DEG2RAD (PI/180.0f)
#endif
#ifndef RAD2DEG
    #define RAD2DEG (180.0f/PI)
#endif

// Allow custom memory allocators
// NOTE: Require recompiling raylib sources
#ifndef RL_MALLOC
    #define RL_MALLOC(sz)       malloc(sz)
#endif
#ifndef RL_CALLOC
    #define RL_CALLOC(n,sz)     calloc(n,sz)
#endif
#ifndef RL_REALLOC
    #define RL_REALLOC(ptr,sz)  realloc(ptr,sz)
#endif
#ifndef RL_FREE
    #define RL_FREE(ptr)        free(ptr)
#endif

// NOTE: MSVC C++ compiler does not support compound literals (C99 feature)
// Plain structures in C++ (without constructors) can be initialized with { }
// This is called aggregate initialization (C++11 feature)
#if defined(__cplusplus)
    #define CLITERAL(type)      type
#else
    #define CLITERAL(type)      (type)
#endif

// Some compilers (mostly macos clang) default to C++98,
// where aggregate initialization can't be used
// So, give a more clear error stating how to fix this
#if !defined(_MSC_VER) && (defined(__cplusplus) && __cplusplus < 201103L)
    #error "C++11 or later is required. Add -std=c++11"
#endif

// NOTE: We set some defines with some data types declared by raylib
// Other modules (raymath, rlgl) also require some of those types, so,
// to be able to use those other modules as standalone (not depending on raylib)
// this defines are very useful for internal check and avoid type (re)definitions
#define RL_COLOR_TYPE
#define RL_RECTANGLE_TYPE
#define RL_VECTOR2_TYPE
#define RL_VECTOR3_TYPE
#define RL_VECTOR4_TYPE
#define RL_QUATERNION_TYPE
#define RL_MATRIX_TYPE

// Some Basic Colors
// NOTE: Custom raylib color palette for amazing visuals on WHITE background
#define LIGHTGRAY  CLITERAL(Color){ 200, 200, 200, 255 }   // Light Gray
#define GRAY       CLITERAL(Color){ 130, 130, 130, 255 }   // Gray
#define DARKGRAY   CLITERAL(Color){ 80, 80, 80, 255 }      // Dark Gray
#define YELLOW     CLITERAL(Color){ 253, 249, 0, 255 }     // Yellow
#define GOLD       CLITERAL(Color){ 255, 203, 0, 255 }     // Gold
#define ORANGE     CLITERAL(Color){ 255, 161, 0, 255 }     // Orange
#define PINK       CLITERAL(Color){ 255, 109, 194, 255 }   // Pink
#define RED        CLITERAL(Color){ 230, 41, 55, 255 }     // Red
#define MAROON     CLITERAL(Color){ 190, 33, 55, 255 }     // Maroon
#define GREEN      CLITERAL(Color){ 0, 228, 48, 255 }      // Green
#define LIME       CLITERAL(Color){ 0, 158, 47, 255 }      // Lime
#define DARKGREEN  CLITERAL(Color){ 0, 117, 44, 255 }      // Dark Green
#define SKYBLUE    CLITERAL(Color){ 102, 191, 255, 255 }   // Sky Blue
#define BLUE       CLITERAL(Color){ 0, 121, 241, 255 }     // Blue
#define DARKBLUE   CLITERAL(Color){ 0, 82, 172, 255 }      // Dark Blue
#define PURPLE     CLITERAL(Color){ 200, 122, 255, 255 }   // Purple
#define VIOLET     CLITERAL(Color){ 135, 60, 190, 255 }    // Violet
#define DARKPURPLE CLITERAL(Color){ 112, 31, 126, 255 }    // Dark Purple
#define BEIGE      CLITERAL(Color){ 211, 176, 131, 255 }   // Beige
#define BROWN      CLITERAL(Color){ 127, 106, 79, 255 }    // Brown
#define DARKBROWN  CLITERAL(Color){ 76, 63, 47, 255 }      // Dark Brown

#define WHITE      CLITERAL(Color){ 255, 255, 255, 255 }   // White
#define BLACK      CLITERAL(Color){ 0, 0, 0, 255 }         // Black
#define BLANK      CLITERAL(Color){ 0, 0, 0, 0 }           // Blank (Transparent)
#define MAGENTA    CLITERAL(Color){ 255, 0, 255, 255 }     // Magenta
#define RAYWHITE   CLITERAL(Color){ 245, 245, 245, 255 }   // My own White (raylib logo)

//----------------------------------------------------------------------------------
// Structures Definition
//----------------------------------------------------------------------------------
// Boolean type
#if (defined(__STDC__) && __STDC_VERSION__ >= 199901L) || (defined(_MSC_VER) && _MSC_VER >= 1800)
    #include <stdbool.h>
#elif !defined(__cplusplus) && !defined(bool)
    typedef enum bool { false = 0, true = !false } bool;
    #define RL_BOOL_TYPE
#endif

// Vector2, 2 components
typedef struct Vector2 {
    float x;                // Vector x component
    float y;                // Vector y component
} Vector2;

// Vector3, 3 components
typedef struct Vector3 {
    float x;                // Vector x component
    float y;                // Vector y component
    float z;                // Vector z component
} Vector3;

// Vector4, 4 components
typedef struct Vector4 {
    float x;                // Vector x component
    float y;                // Vector y component
    float z;                // Vector z component
    float w;                // Vector w component
} Vector4;

// Quaternion, 4 components (Vector4 alias)
typedef Vector4 Quaternion;

// Matrix, 4x4 components, column major, OpenGL style, right-handed
typedef struct Matrix {
    float m0, m4, m8, m12;  // Matrix first row (4 components)
    float m1, m5, m9, m13;  // Matrix second row (4 components)
    float m2, m6, m10, m14; // Matrix third row (4 components)
    float m3, m7, m11, m15; // Matrix fourth row (4 components)
} Matrix;

// Color, 4 components, R8G8B8A8 (32bit)
typedef struct Color {
    unsigned char r;        // Color red value
    unsigned char g;        // Color green value
    unsigned char b;        // Color blue value
    unsigned char a;        // Color alpha value
} Color;

// Rectangle, 4 components
typedef struct Rectangle {
    float x;                // Rectangle top-left corner position x
    float y;                // Rectangle top-left corner position y
    float width;            // Rectangle width
    float height;           // Rectangle height
} Rectangle;

// Image, pixel data stored in CPU memory (RAM)
typedef struct Image {
    void *data;             // Image raw data
    int width;              // Image base width
    int height;             // Image base height
    int mipmaps;            // Mipmap levels, 1 by default
    int format;             // Data format (PixelFormat type)
} Image;

// Texture, tex data stored in GPU memory (VRAM)
typedef struct Texture {
    unsigned int id;        // OpenGL texture id
    int width;              // Texture base width
    int height;             // Texture base height
    int mipmaps;            // Mipmap levels, 1 by default
    int format;             // Data format (PixelFormat type)
} Texture;

// Texture2D, same as Texture
typedef Texture Texture2D;

// TextureCubemap, same as Texture
typedef Texture TextureCubemap;

// RenderTexture, fbo for texture rendering
typedef struct RenderTexture {
    unsigned int id;        // OpenGL framebuffer object id
    Texture texture;        // Color buffer attachment texture
    Texture depth;          // Depth buffer attachment texture
} RenderTexture;

// RenderTexture2D, same as RenderTexture
typedef RenderTexture RenderTexture2D;

// NPatchInfo, n-patch layout info
typedef struct NPatchInfo {
    Rectangle source;       // Texture source rectangle
    int left;               // Left border offset
    int top;                // Top border offset
    int right;              // Right border offset
    int bottom;             // Bottom border offset
    int layout;             // Layout of the n-patch: 3x3, 1x3 or 3x1
} NPatchInfo;

// GlyphInfo, font characters glyphs info
typedef struct GlyphInfo {
    int value;              // Character value (Unicode)
    int offsetX;            // Character offset X when drawing
    int offsetY;            // Character offset Y when drawing
    int advanceX;           // Character advance position X
    Image image;            // Character image data
} GlyphInfo;

// Font, font texture and GlyphInfo array data
typedef struct Font {
    int baseSize;           // Base size (default chars height)
    int glyphCount;         // Number of glyph characters
    int glyphPadding;       // Padding around the glyph characters
    Texture2D texture;      // Texture atlas containing the glyphs
    Rectangle *recs;        // Rectangles in texture for the glyphs
    GlyphInfo *glyphs;      // Glyphs info data
} Font;

// Camera, defines position/orientation in 3d space
typedef struct Camera3D {
    Vector3 position;       // Camera position
    Vector3 target;         // Camera target it looks-at
    Vector3 up;             // Camera up vector (rotation over its axis)
    float fovy;             // Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
    int projection;         // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
} Camera3D;

typedef Camera3D Camera;    // Camera type fallback, defaults to Camera3D

// Camera2D, defines position/orientation in 2d space
typedef struct Camera2D {
    Vector2 offset;         // Camera offset (displacement from target)
    Vector2 target;         // Camera target (rotation and zoom origin)
    float rotation;         // Camera rotation in degrees
    float zoom;             // Camera zoom (scaling), should be 1.0f by default
} Camera2D;

// Mesh, vertex data and vao/vbo
typedef struct Mesh {
    int vertexCount;        // Number of vertices stored in arrays
    int triangleCount;      // Number of triangles stored (indexed or not)

    // Vertex attributes data
    float *vertices;        // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
    float *texcoords;       // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
    float *texcoords2;      // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
    float *normals;         // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
    float *tangents;        // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
    unsigned char *colors;      // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
    unsigned short *indices;    // Vertex indices (in case vertex data comes indexed)

    // Animation vertex data
    float *animVertices;    // Animated vertex positions (after bones transformations)
    float *animNormals;     // Animated normals (after bones transformations)
    unsigned char *boneIds; // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning) (shader-location = 6)
    float *boneWeights;     // Vertex bone weight, up to 4 bones influence by vertex (skinning) (shader-location = 7)
    Matrix *boneMatrices;   // Bones animated transformation matrices
    int boneCount;          // Number of bones

    // OpenGL identifiers
    unsigned int vaoId;     // OpenGL Vertex Array Object id
    unsigned int *vboId;    // OpenGL Vertex Buffer Objects id (default vertex data)
} Mesh;

// Shader
typedef struct Shader {
    unsigned int id;        // Shader program id
    int *locs;              // Shader locations array (RL_MAX_SHADER_LOCATIONS)
} Shader;

// MaterialMap
typedef struct MaterialMap {
    Texture2D texture;      // Material map texture
    Color color;            // Material map color
    float value;            // Material map value
} MaterialMap;

// Material, includes shader and maps
typedef struct Material {
    Shader shader;          // Material shader
    MaterialMap *maps;      // Material maps array (MAX_MATERIAL_MAPS)
    float params[4];        // Material generic parameters (if required)
} Material;

// Transform, vertex transformation data
typedef struct Transform {
    Vector3 translation;    // Translation
    Quaternion rotation;    // Rotation
    Vector3 scale;          // Scale
} Transform;

// Bone, skeletal animation bone
typedef struct BoneInfo {
    char name[32];          // Bone name
    int parent;             // Bone parent
} BoneInfo;

// Model, meshes, materials and animation data
typedef struct Model {
    Matrix transform;       // Local transform matrix

    int meshCount;          // Number of meshes
    int materialCount;      // Number of materials
    Mesh *meshes;           // Meshes array
    Material *materials;    // Materials array
    int *meshMaterial;      // Mesh material number

    // Animation data
    int boneCount;          // Number of bones
    BoneInfo *bones;        // Bones information (skeleton)
    Transform *bindPose;    // Bones base transformation (pose)
} Model;

// ModelAnimation
typedef struct ModelAnimation {
    int boneCount;          // Number of bones
    int frameCount;         // Number of animation frames
    BoneInfo *bones;        // Bones information (skeleton)
    Transform **framePoses; // Poses array by frame
    char name[32];          // Animation name
} ModelAnimation;

// Ray, ray for raycasting
typedef struct Ray {
    Vector3 position;       // Ray position (origin)
    Vector3 direction;      // Ray direction (normalized)
} Ray;

// RayCollision, ray hit information
typedef struct RayCollision {
    bool hit;               // Did the ray hit something?
    float distance;         // Distance to the nearest hit
    Vector3 point;          // Point of the nearest hit
    Vector3 normal;         // Surface normal of hit
} RayCollision;

// BoundingBox
typedef struct BoundingBox {
    Vector3 min;            // Minimum vertex box-corner
    Vector3 max;            // Maximum vertex box-corner
} BoundingBox;

// Wave, audio wave data
typedef struct Wave {
    unsigned int frameCount;    // Total number of frames (considering channels)
    unsigned int sampleRate;    // Frequency (samples per second)
    unsigned int sampleSize;    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    unsigned int channels;      // Number of channels (1-mono, 2-stereo, ...)
    void *data;                 // Buffer data pointer
} Wave;

// Opaque structs declaration
// NOTE: Actual structs are defined internally in raudio module
typedef struct rAudioBuffer rAudioBuffer;
typedef struct rAudioProcessor rAudioProcessor;

// AudioStream, custom audio stream
typedef struct AudioStream {
    rAudioBuffer *buffer;       // Pointer to internal data used by the audio system
    rAudioProcessor *processor; // Pointer to internal data processor, useful for audio effects

    unsigned int sampleRate;    // Frequency (samples per second)
    unsigned int sampleSize;    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    unsigned int channels;      // Number of channels (1-mono, 2-stereo, ...)
} AudioStream;

// Sound
typedef struct Sound {
    AudioStream stream;         // Audio stream
    unsigned int frameCount;    // Total number of frames (considering channels)
} Sound;

// Music, audio stream, anything longer than ~10 seconds should be streamed
typedef struct Music {
    AudioStream stream;         // Audio stream
    unsigned int frameCount;    // Total number of frames (considering channels)
    bool looping;               // Music looping enable

    int ctxType;                // Type of music context (audio filetype)
    void *ctxData;              // Audio context data, depends on type
} Music;

// VrDeviceInfo, Head-Mounted-Display device parameters
typedef struct VrDeviceInfo {
    int hResolution;                // Horizontal resolution in pixels
    int vResolution;                // Vertical resolution in pixels
    float hScreenSize;              // Horizontal size in meters
    float vScreenSize;              // Vertical size in meters
    float eyeToScreenDistance;      // Distance between eye and display in meters
    float lensSeparationDistance;   // Lens separation distance in meters
    float interpupillaryDistance;   // IPD (distance between pupils) in meters
    float lensDistortionValues[4];  // Lens distortion constant parameters
    float chromaAbCorrection[4];    // Chromatic aberration correction parameters
} VrDeviceInfo;

// VrStereoConfig, VR stereo rendering configuration for simulator
typedef struct VrStereoConfig {
    Matrix projection[2];           // VR projection matrices (per eye)
    Matrix viewOffset[2];           // VR view offset matrices (per eye)
    float leftLensCenter[2];        // VR left lens center
    float rightLensCenter[2];       // VR right lens center
    float leftScreenCenter[2];      // VR left screen center
    float rightScreenCenter[2];     // VR right screen center
    float scale[2];                 // VR distortion scale
    float scaleIn[2];               // VR distortion scale in
} VrStereoConfig;

// File path list
typedef struct FilePathList {
    unsigned int capacity;          // Filepaths max entries
    unsigned int count;             // Filepaths entries count
    char **paths;                   // Filepaths entries
} FilePathList;

// Automation event
typedef struct AutomationEvent {
    unsigned int frame;             // Event frame
    unsigned int type;              // Event type (AutomationEventType)
    int params[4];                  // Event parameters (if required)
} AutomationEvent;

// Automation event list
typedef struct AutomationEventList {
    unsigned int capacity;          // Events max entries (MAX_AUTOMATION_EVENTS)
    unsigned int count;             // Events entries count
    AutomationEvent *events;        // Events entries
} AutomationEventList;

//----------------------------------------------------------------------------------
// æä¸¾å®ä¹
//----------------------------------------------------------------------------------
// ç³»ç»/çªå£éç½®æ å¿
// æ³¨æ: æ¯ä¸ªä½ä»£è¡¨ä¸ç§ç¶æ (ä½¿ç¨ä½æ©ç æä½)
// é»è®¤æåµä¸ï¼æææ å¿é½è®¾ç½®ä¸º 0
typedef enum {
    FLAG_VSYNC_HINT         = 0x00000040,   // è®¾ç½®ä»¥å°è¯å¨GPUä¸å¯ç¨åç´åæ­¥
    FLAG_FULLSCREEN_MODE    = 0x00000002,   // è®¾ç½®ä»¥å¨å±æ¨¡å¼è¿è¡ç¨åº
    FLAG_WINDOW_RESIZABLE   = 0x00000004,   // è®¾ç½®ä»¥åè®¸çªå£å¯è°æ´å¤§å°
    FLAG_WINDOW_UNDECORATED = 0x00000008,   // è®¾ç½®ä»¥ç¦ç¨çªå£è£é¥° (è¾¹æ¡åæé®)
    FLAG_WINDOW_HIDDEN      = 0x00000080,   // è®¾ç½®ä»¥éèçªå£
    FLAG_WINDOW_MINIMIZED   = 0x00000200,   // è®¾ç½®ä»¥æå°åçªå£ (å¾æ å)
    FLAG_WINDOW_MAXIMIZED   = 0x00000400,   // è®¾ç½®ä»¥æå¤§åçªå£ (æ©å±å°æ¾ç¤ºå¨)
    FLAG_WINDOW_UNFOCUSED   = 0x00000800,   // è®¾ç½®çªå£ä¸ºéèç¦ç¶æ
    FLAG_WINDOW_TOPMOST     = 0x00001000,   // è®¾ç½®çªå£å§ç»ç½®é¡¶
    FLAG_WINDOW_ALWAYS_RUN  = 0x00000100,   // è®¾ç½®ä»¥åè®¸çªå£å¨æå°åæ¶ç»§ç»­è¿è¡
    FLAG_WINDOW_TRANSPARENT = 0x00000010,   // è®¾ç½®ä»¥åè®¸éæå¸§ç¼å²åº
    FLAG_WINDOW_HIGHDPI     = 0x00002000,   // è®¾ç½®ä»¥æ¯æé«DPI
    FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000, // è®¾ç½®ä»¥æ¯æé¼ æ ç©¿éï¼ä»å¨FLAG_WINDOW_UNDECORATEDæ¶æ¯æ
    FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000, // è®¾ç½®ä»¥æ è¾¹æ¡çªå£æ¨¡å¼è¿è¡ç¨åº
    FLAG_MSAA_4X_HINT       = 0x00000020,   // è®¾ç½®ä»¥å°è¯å¯ç¨4åå¤ééæ ·æé¯é½¿
    FLAG_INTERLACED_HINT    = 0x00010000    // è®¾ç½®ä»¥å°è¯å¯ç¨éè¡è§é¢æ ¼å¼ (éç¨äºV3D)
} ConfigFlags;

// Trace log level
// NOTE: Organized by priority level
typedef enum {
    LOG_ALL = 0,        // Display all logs
    LOG_TRACE,          // Trace logging, intended for internal use only
    LOG_DEBUG,          // Debug logging, used for internal debugging, it should be disabled on release builds
    LOG_INFO,           // Info logging, used for program execution info
    LOG_WARNING,        // Warning logging, used on recoverable failures
    LOG_ERROR,          // Error logging, used on unrecoverable failures
    LOG_FATAL,          // Fatal logging, used to abort program: exit(EXIT_FAILURE)
    LOG_NONE            // Disable logging
} TraceLogLevel;

// Keyboard keys (US keyboard layout)
// NOTE: Use GetKeyPressed() to allow redefining
// required keys for alternative layouts
typedef enum {
    KEY_NULL            = 0,        // Key: NULL, used for no key pressed
    // Alphanumeric keys
    KEY_APOSTROPHE      = 39,       // Key: '
    KEY_COMMA           = 44,       // Key: ,
    KEY_MINUS           = 45,       // Key: -
    KEY_PERIOD          = 46,       // Key: .
    KEY_SLASH           = 47,       // Key: /
    KEY_ZERO            = 48,       // Key: 0
    KEY_ONE             = 49,       // Key: 1
    KEY_TWO             = 50,       // Key: 2
    KEY_THREE           = 51,       // Key: 3
    KEY_FOUR            = 52,       // Key: 4
    KEY_FIVE            = 53,       // Key: 5
    KEY_SIX             = 54,       // Key: 6
    KEY_SEVEN           = 55,       // Key: 7
    KEY_EIGHT           = 56,       // Key: 8
    KEY_NINE            = 57,       // Key: 9
    KEY_SEMICOLON       = 59,       // Key: ;
    KEY_EQUAL           = 61,       // Key: =
    KEY_A               = 65,       // Key: A | a
    KEY_B               = 66,       // Key: B | b
    KEY_C               = 67,       // Key: C | c
    KEY_D               = 68,       // Key: D | d
    KEY_E               = 69,       // Key: E | e
    KEY_F               = 70,       // Key: F | f
    KEY_G               = 71,       // Key: G | g
    KEY_H               = 72,       // Key: H | h
    KEY_I               = 73,       // Key: I | i
    KEY_J               = 74,       // Key: J | j
    KEY_K               = 75,       // Key: K | k
    KEY_L               = 76,       // Key: L | l
    KEY_M               = 77,       // Key: M | m
    KEY_N               = 78,       // Key: N | n
    KEY_O               = 79,       // Key: O | o
    KEY_P               = 80,       // Key: P | p
    KEY_Q               = 81,       // Key: Q | q
    KEY_R               = 82,       // Key: R | r
    KEY_S               = 83,       // Key: S | s
    KEY_T               = 84,       // Key: T | t
    KEY_U               = 85,       // Key: U | u
    KEY_V               = 86,       // Key: V | v
    KEY_W               = 87,       // Key: W | w
    KEY_X               = 88,       // Key: X | x
    KEY_Y               = 89,       // Key: Y | y
    KEY_Z               = 90,       // Key: Z | z
    KEY_LEFT_BRACKET    = 91,       // Key: [
    KEY_BACKSLASH       = 92,       // Key: '\'
    KEY_RIGHT_BRACKET   = 93,       // Key: ]
    KEY_GRAVE           = 96,       // Key: `
    // Function keys
    KEY_SPACE           = 32,       // Key: Space
    KEY_ESCAPE          = 256,      // Key: Esc
    KEY_ENTER           = 257,      // Key: Enter
    KEY_TAB             = 258,      // Key: Tab
    KEY_BACKSPACE       = 259,      // Key: Backspace
    KEY_INSERT          = 260,      // Key: Ins
    KEY_DELETE          = 261,      // Key: Del
    KEY_RIGHT           = 262,      // Key: Cursor right
    KEY_LEFT            = 263,      // Key: Cursor left
    KEY_DOWN            = 264,      // Key: Cursor down
    KEY_UP              = 265,      // Key: Cursor up
    KEY_PAGE_UP         = 266,      // Key: Page up
    KEY_PAGE_DOWN       = 267,      // Key: Page down
    KEY_HOME            = 268,      // Key: Home
    KEY_END             = 269,      // Key: End
    KEY_CAPS_LOCK       = 280,      // Key: Caps lock
    KEY_SCROLL_LOCK     = 281,      // Key: Scroll down
    KEY_NUM_LOCK        = 282,      // Key: Num lock
    KEY_PRINT_SCREEN    = 283,      // Key: Print screen
    KEY_PAUSE           = 284,      // Key: Pause
    KEY_F1              = 290,      // Key: F1
    KEY_F2              = 291,      // Key: F2
    KEY_F3              = 292,      // Key: F3
    KEY_F4              = 293,      // Key: F4
    KEY_F5              = 294,      // Key: F5
    KEY_F6              = 295,      // Key: F6
    KEY_F7              = 296,      // Key: F7
    KEY_F8              = 297,      // Key: F8
    KEY_F9              = 298,      // Key: F9
    KEY_F10             = 299,      // Key: F10
    KEY_F11             = 300,      // Key: F11
    KEY_F12             = 301,      // Key: F12
    KEY_LEFT_SHIFT      = 340,      // Key: Shift left
    KEY_LEFT_CONTROL    = 341,      // Key: Control left
    KEY_LEFT_ALT        = 342,      // Key: Alt left
    KEY_LEFT_SUPER      = 343,      // Key: Super left
    KEY_RIGHT_SHIFT     = 344,      // Key: Shift right
    KEY_RIGHT_CONTROL   = 345,      // Key: Control right
    KEY_RIGHT_ALT       = 346,      // Key: Alt right
    KEY_RIGHT_SUPER     = 347,      // Key: Super right
    KEY_KB_MENU         = 348,      // Key: KB menu
    // Keypad keys
    KEY_KP_0            = 320,      // Key: Keypad 0
    KEY_KP_1            = 321,      // Key: Keypad 1
    KEY_KP_2            = 322,      // Key: Keypad 2
    KEY_KP_3            = 323,      // Key: Keypad 3
    KEY_KP_4            = 324,      // Key: Keypad 4
    KEY_KP_5            = 325,      // Key: Keypad 5
    KEY_KP_6            = 326,      // Key: Keypad 6
    KEY_KP_7            = 327,      // Key: Keypad 7
    KEY_KP_8            = 328,      // Key: Keypad 8
    KEY_KP_9            = 329,      // Key: Keypad 9
    KEY_KP_DECIMAL      = 330,      // Key: Keypad .
    KEY_KP_DIVIDE       = 331,      // Key: Keypad /
    KEY_KP_MULTIPLY     = 332,      // Key: Keypad *
    KEY_KP_SUBTRACT     = 333,      // Key: Keypad -
    KEY_KP_ADD          = 334,      // Key: Keypad +
    KEY_KP_ENTER        = 335,      // Key: Keypad Enter
    KEY_KP_EQUAL        = 336,      // Key: Keypad =
    // Android key buttons
    KEY_BACK            = 4,        // Key: Android back button
    KEY_MENU            = 5,        // Key: Android menu button
    KEY_VOLUME_UP       = 24,       // Key: Android volume up button
    KEY_VOLUME_DOWN     = 25        // Key: Android volume down button
} KeyboardKey;

// Add backwards compatibility support for deprecated names
#define MOUSE_LEFT_BUTTON   MOUSE_BUTTON_LEFT
#define MOUSE_RIGHT_BUTTON  MOUSE_BUTTON_RIGHT
#define MOUSE_MIDDLE_BUTTON MOUSE_BUTTON_MIDDLE

// Mouse buttons
typedef enum {
    MOUSE_BUTTON_LEFT    = 0,       // Mouse button left
    MOUSE_BUTTON_RIGHT   = 1,       // Mouse button right
    MOUSE_BUTTON_MIDDLE  = 2,       // Mouse button middle (pressed wheel)
    MOUSE_BUTTON_SIDE    = 3,       // Mouse button side (advanced mouse device)
    MOUSE_BUTTON_EXTRA   = 4,       // Mouse button extra (advanced mouse device)
    MOUSE_BUTTON_FORWARD = 5,       // Mouse button forward (advanced mouse device)
    MOUSE_BUTTON_BACK    = 6,       // Mouse button back (advanced mouse device)
} MouseButton;

// Mouse cursor
typedef enum {
    MOUSE_CURSOR_DEFAULT       = 0,     // Default pointer shape
    MOUSE_CURSOR_ARROW         = 1,     // Arrow shape
    MOUSE_CURSOR_IBEAM         = 2,     // Text writing cursor shape
    MOUSE_CURSOR_CROSSHAIR     = 3,     // Cross shape
    MOUSE_CURSOR_POINTING_HAND = 4,     // Pointing hand cursor
    MOUSE_CURSOR_RESIZE_EW     = 5,     // Horizontal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NS     = 6,     // Vertical resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NWSE   = 7,     // Top-left to bottom-right diagonal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NESW   = 8,     // The top-right to bottom-left diagonal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_ALL    = 9,     // The omnidirectional resize/move cursor shape
    MOUSE_CURSOR_NOT_ALLOWED   = 10     // The operation-not-allowed shape
} MouseCursor;

// Gamepad buttons
typedef enum {
    GAMEPAD_BUTTON_UNKNOWN = 0,         // Unknown button, just for error checking
    GAMEPAD_BUTTON_LEFT_FACE_UP,        // Gamepad left DPAD up button
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT,     // Gamepad left DPAD right button
    GAMEPAD_BUTTON_LEFT_FACE_DOWN,      // Gamepad left DPAD down button
    GAMEPAD_BUTTON_LEFT_FACE_LEFT,      // Gamepad left DPAD left button
    GAMEPAD_BUTTON_RIGHT_FACE_UP,       // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,    // Gamepad right button right (i.e. PS3: Circle, Xbox: B)
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN,     // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT,     // Gamepad right button left (i.e. PS3: Square, Xbox: X)
    GAMEPAD_BUTTON_LEFT_TRIGGER_1,      // Gamepad top/back trigger left (first), it could be a trailing button
    GAMEPAD_BUTTON_LEFT_TRIGGER_2,      // Gamepad top/back trigger left (second), it could be a trailing button
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1,     // Gamepad top/back trigger right (first), it could be a trailing button
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2,     // Gamepad top/back trigger right (second), it could be a trailing button
    GAMEPAD_BUTTON_MIDDLE_LEFT,         // Gamepad center buttons, left one (i.e. PS3: Select)
    GAMEPAD_BUTTON_MIDDLE,              // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
    GAMEPAD_BUTTON_MIDDLE_RIGHT,        // Gamepad center buttons, right one (i.e. PS3: Start)
    GAMEPAD_BUTTON_LEFT_THUMB,          // Gamepad joystick pressed button left
    GAMEPAD_BUTTON_RIGHT_THUMB          // Gamepad joystick pressed button right
} GamepadButton;

// Gamepad axis
typedef enum {
    GAMEPAD_AXIS_LEFT_X        = 0,     // Gamepad left stick X axis
    GAMEPAD_AXIS_LEFT_Y        = 1,     // Gamepad left stick Y axis
    GAMEPAD_AXIS_RIGHT_X       = 2,     // Gamepad right stick X axis
    GAMEPAD_AXIS_RIGHT_Y       = 3,     // Gamepad right stick Y axis
    GAMEPAD_AXIS_LEFT_TRIGGER  = 4,     // Gamepad back trigger left, pressure level: [1..-1]
    GAMEPAD_AXIS_RIGHT_TRIGGER = 5      // Gamepad back trigger right, pressure level: [1..-1]
} GamepadAxis;

// Material map index
typedef enum {
    MATERIAL_MAP_ALBEDO = 0,        // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
    MATERIAL_MAP_METALNESS,         // Metalness material (same as: MATERIAL_MAP_SPECULAR)
    MATERIAL_MAP_NORMAL,            // Normal material
    MATERIAL_MAP_ROUGHNESS,         // Roughness material
    MATERIAL_MAP_OCCLUSION,         // Ambient occlusion material
    MATERIAL_MAP_EMISSION,          // Emission material
    MATERIAL_MAP_HEIGHT,            // Heightmap material
    MATERIAL_MAP_CUBEMAP,           // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    MATERIAL_MAP_IRRADIANCE,        // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    MATERIAL_MAP_PREFILTER,         // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    MATERIAL_MAP_BRDF               // Brdf material
} MaterialMapIndex;

#define MATERIAL_MAP_DIFFUSE      MATERIAL_MAP_ALBEDO
#define MATERIAL_MAP_SPECULAR     MATERIAL_MAP_METALNESS

// Shader location index
typedef enum {
    SHADER_LOC_VERTEX_POSITION = 0, // Shader location: vertex attribute: position
    SHADER_LOC_VERTEX_TEXCOORD01,   // Shader location: vertex attribute: texcoord01
    SHADER_LOC_VERTEX_TEXCOORD02,   // Shader location: vertex attribute: texcoord02
    SHADER_LOC_VERTEX_NORMAL,       // Shader location: vertex attribute: normal
    SHADER_LOC_VERTEX_TANGENT,      // Shader location: vertex attribute: tangent
    SHADER_LOC_VERTEX_COLOR,        // Shader location: vertex attribute: color
    SHADER_LOC_MATRIX_MVP,          // Shader location: matrix uniform: model-view-projection
    SHADER_LOC_MATRIX_VIEW,         // Shader location: matrix uniform: view (camera transform)
    SHADER_LOC_MATRIX_PROJECTION,   // Shader location: matrix uniform: projection
    SHADER_LOC_MATRIX_MODEL,        // Shader location: matrix uniform: model (transform)
    SHADER_LOC_MATRIX_NORMAL,       // Shader location: matrix uniform: normal
    SHADER_LOC_VECTOR_VIEW,         // Shader location: vector uniform: view
    SHADER_LOC_COLOR_DIFFUSE,       // Shader location: vector uniform: diffuse color
    SHADER_LOC_COLOR_SPECULAR,      // Shader location: vector uniform: specular color
    SHADER_LOC_COLOR_AMBIENT,       // Shader location: vector uniform: ambient color
    SHADER_LOC_MAP_ALBEDO,          // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
    SHADER_LOC_MAP_METALNESS,       // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
    SHADER_LOC_MAP_NORMAL,          // Shader location: sampler2d texture: normal
    SHADER_LOC_MAP_ROUGHNESS,       // Shader location: sampler2d texture: roughness
    SHADER_LOC_MAP_OCCLUSION,       // Shader location: sampler2d texture: occlusion
    SHADER_LOC_MAP_EMISSION,        // Shader location: sampler2d texture: emission
    SHADER_LOC_MAP_HEIGHT,          // Shader location: sampler2d texture: height
    SHADER_LOC_MAP_CUBEMAP,         // Shader location: samplerCube texture: cubemap
    SHADER_LOC_MAP_IRRADIANCE,      // Shader location: samplerCube texture: irradiance
    SHADER_LOC_MAP_PREFILTER,       // Shader location: samplerCube texture: prefilter
    SHADER_LOC_MAP_BRDF,            // Shader location: sampler2d texture: brdf
    SHADER_LOC_VERTEX_BONEIDS,      // Shader location: vertex attribute: boneIds
    SHADER_LOC_VERTEX_BONEWEIGHTS,  // Shader location: vertex attribute: boneWeights
    SHADER_LOC_BONE_MATRICES        // Shader location: array of matrices uniform: boneMatrices
} ShaderLocationIndex;

#define SHADER_LOC_MAP_DIFFUSE      SHADER_LOC_MAP_ALBEDO
#define SHADER_LOC_MAP_SPECULAR     SHADER_LOC_MAP_METALNESS

// Shader uniform data type
typedef enum {
    SHADER_UNIFORM_FLOAT = 0,       // Shader uniform type: float
    SHADER_UNIFORM_VEC2,            // Shader uniform type: vec2 (2 float)
    SHADER_UNIFORM_VEC3,            // Shader uniform type: vec3 (3 float)
    SHADER_UNIFORM_VEC4,            // Shader uniform type: vec4 (4 float)
    SHADER_UNIFORM_INT,             // Shader uniform type: int
    SHADER_UNIFORM_IVEC2,           // Shader uniform type: ivec2 (2 int)
    SHADER_UNIFORM_IVEC3,           // Shader uniform type: ivec3 (3 int)
    SHADER_UNIFORM_IVEC4,           // Shader uniform type: ivec4 (4 int)
    SHADER_UNIFORM_SAMPLER2D        // Shader uniform type: sampler2d
} ShaderUniformDataType;

// Shader attribute data types
typedef enum {
    SHADER_ATTRIB_FLOAT = 0,        // Shader attribute type: float
    SHADER_ATTRIB_VEC2,             // Shader attribute type: vec2 (2 float)
    SHADER_ATTRIB_VEC3,             // Shader attribute type: vec3 (3 float)
    SHADER_ATTRIB_VEC4              // Shader attribute type: vec4 (4 float)
} ShaderAttributeDataType;

// Pixel formats
// NOTE: Support depends on OpenGL version and platform
typedef enum {
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1, // 8 bit per pixel (no alpha)
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,    // 8*2 bpp (2 channels)
    PIXELFORMAT_UNCOMPRESSED_R5G6B5,        // 16 bpp
    PIXELFORMAT_UNCOMPRESSED_R8G8B8,        // 24 bpp
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,      // 16 bpp (1 bit alpha)
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,      // 16 bpp (4 bit alpha)
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,      // 32 bpp
    PIXELFORMAT_UNCOMPRESSED_R32,           // 32 bpp (1 channel - float)
    PIXELFORMAT_UNCOMPRESSED_R32G32B32,     // 32*3 bpp (3 channels - float)
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,  // 32*4 bpp (4 channels - float)
    PIXELFORMAT_UNCOMPRESSED_R16,           // 16 bpp (1 channel - half float)
    PIXELFORMAT_UNCOMPRESSED_R16G16B16,     // 16*3 bpp (3 channels - half float)
    PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,  // 16*4 bpp (4 channels - half float)
    PIXELFORMAT_COMPRESSED_DXT1_RGB,        // 4 bpp (no alpha)
    PIXELFORMAT_COMPRESSED_DXT1_RGBA,       // 4 bpp (1 bit alpha)
    PIXELFORMAT_COMPRESSED_DXT3_RGBA,       // 8 bpp
    PIXELFORMAT_COMPRESSED_DXT5_RGBA,       // 8 bpp
    PIXELFORMAT_COMPRESSED_ETC1_RGB,        // 4 bpp
    PIXELFORMAT_COMPRESSED_ETC2_RGB,        // 4 bpp
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,   // 8 bpp
    PIXELFORMAT_COMPRESSED_PVRT_RGB,        // 4 bpp
    PIXELFORMAT_COMPRESSED_PVRT_RGBA,       // 4 bpp
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,   // 8 bpp
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA    // 2 bpp
} PixelFormat;

// Texture parameters: filter mode
// NOTE 1: Filtering considers mipmaps if available in the texture
// NOTE 2: Filter is accordingly set for minification and magnification
typedef enum {
    TEXTURE_FILTER_POINT = 0,               // No filter, just pixel approximation
    TEXTURE_FILTER_BILINEAR,                // Linear filtering
    TEXTURE_FILTER_TRILINEAR,               // Trilinear filtering (linear with mipmaps)
    TEXTURE_FILTER_ANISOTROPIC_4X,          // Anisotropic filtering 4x
    TEXTURE_FILTER_ANISOTROPIC_8X,          // Anisotropic filtering 8x
    TEXTURE_FILTER_ANISOTROPIC_16X,         // Anisotropic filtering 16x
} TextureFilter;

// Texture parameters: wrap mode
typedef enum {
    TEXTURE_WRAP_REPEAT = 0,                // Repeats texture in tiled mode
    TEXTURE_WRAP_CLAMP,                     // Clamps texture to edge pixel in tiled mode
    TEXTURE_WRAP_MIRROR_REPEAT,             // Mirrors and repeats the texture in tiled mode
    TEXTURE_WRAP_MIRROR_CLAMP               // Mirrors and clamps to border the texture in tiled mode
} TextureWrap;

// Cubemap layouts
typedef enum {
    CUBEMAP_LAYOUT_AUTO_DETECT = 0,         // Automatically detect layout type
    CUBEMAP_LAYOUT_LINE_VERTICAL,           // Layout is defined by a vertical line with faces
    CUBEMAP_LAYOUT_LINE_HORIZONTAL,         // Layout is defined by a horizontal line with faces
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR,     // Layout is defined by a 3x4 cross with cubemap faces
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE     // Layout is defined by a 4x3 cross with cubemap faces
} CubemapLayout;

// Font type, defines generation method
typedef enum {
    FONT_DEFAULT = 0,               // Default font generation, anti-aliased
    FONT_BITMAP,                    // Bitmap font generation, no anti-aliasing
    FONT_SDF                        // SDF font generation, requires external shader
} FontType;

// Color blending modes (pre-defined)
typedef enum {
    BLEND_ALPHA = 0,                // Blend textures considering alpha (default)
    BLEND_ADDITIVE,                 // Blend textures adding colors
    BLEND_MULTIPLIED,               // Blend textures multiplying colors
    BLEND_ADD_COLORS,               // Blend textures adding colors (alternative)
    BLEND_SUBTRACT_COLORS,          // Blend textures subtracting colors (alternative)
    BLEND_ALPHA_PREMULTIPLY,        // Blend premultiplied textures considering alpha
    BLEND_CUSTOM,                   // Blend textures using custom src/dst factors (use rlSetBlendFactors())
    BLEND_CUSTOM_SEPARATE           // Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())
} BlendMode;

// Gesture
// NOTE: Provided as bit-wise flags to enable only desired gestures
typedef enum {
    GESTURE_NONE        = 0,        // No gesture
    GESTURE_TAP         = 1,        // Tap gesture
    GESTURE_DOUBLETAP   = 2,        // Double tap gesture
    GESTURE_HOLD        = 4,        // Hold gesture
    GESTURE_DRAG        = 8,        // Drag gesture
    GESTURE_SWIPE_RIGHT = 16,       // Swipe right gesture
    GESTURE_SWIPE_LEFT  = 32,       // Swipe left gesture
    GESTURE_SWIPE_UP    = 64,       // Swipe up gesture
    GESTURE_SWIPE_DOWN  = 128,      // Swipe down gesture
    GESTURE_PINCH_IN    = 256,      // Pinch in gesture
    GESTURE_PINCH_OUT   = 512       // Pinch out gesture
} Gesture;

// Camera system modes
typedef enum {
    CAMERA_CUSTOM = 0,              // Camera custom, controlled by user (UpdateCamera() does nothing)
    CAMERA_FREE,                    // Camera free mode
    CAMERA_ORBITAL,                 // Camera orbital, around target, zoom supported
    CAMERA_FIRST_PERSON,            // Camera first person
    CAMERA_THIRD_PERSON             // Camera third person
} CameraMode;

// Camera projection
typedef enum {
    CAMERA_PERSPECTIVE = 0,         // Perspective projection
    CAMERA_ORTHOGRAPHIC             // Orthographic projection
} CameraProjection;

// N-patch layout
typedef enum {
    NPATCH_NINE_PATCH = 0,          // Npatch layout: 3x3 tiles
    NPATCH_THREE_PATCH_VERTICAL,    // Npatch layout: 1x3 tiles
    NPATCH_THREE_PATCH_HORIZONTAL   // Npatch layout: 3x1 tiles
} NPatchLayout;

// Callbacks to hook some internal functions
// WARNING: These callbacks are intended for advanced users
typedef void (*TraceLogCallback)(int logLevel, const char *text, va_list args);  // Logging: Redirect trace log messages
typedef unsigned char *(*LoadFileDataCallback)(const char *fileName, int *dataSize);    // FileIO: Load binary data
typedef bool (*SaveFileDataCallback)(const char *fileName, void *data, int dataSize);   // FileIO: Save binary data
typedef char *(*LoadFileTextCallback)(const char *fileName);            // FileIO: Load text data
typedef bool (*SaveFileTextCallback)(const char *fileName, char *text); // FileIO: Save text data

//------------------------------------------------------------------------------------
// Global Variables Definition
//------------------------------------------------------------------------------------
// It's lonely here...

//------------------------------------------------------------------------------------
// Window and Graphics Device Functions (Module: core)
//------------------------------------------------------------------------------------

#if defined(__cplusplus)
extern "C" {            // Prevents name mangling of functions
#endif

// çªå£ç¸å³å½æ°
// åå§åçªå£åOpenGLä¸ä¸æ
RLAPI void InitWindow(int width, int height, const char *title);
// å³é­çªå£å¹¶å¸è½½OpenGLä¸ä¸æ
RLAPI void CloseWindow(void);
// æ£æ¥åºç¨ç¨åºæ¯å¦åºè¯¥å³é­ï¼æä¸ESCé®æç¹å»çªå£å³é­å¾æ ï¼
RLAPI bool WindowShouldClose(void);
// æ£æ¥çªå£æ¯å¦å·²æååå§å
RLAPI bool IsWindowReady(void);
// æ£æ¥çªå£å½åæ¯å¦ä¸ºå¨å±æ¨¡å¼
RLAPI bool IsWindowFullscreen(void);
// æ£æ¥çªå£å½åæ¯å¦éè
RLAPI bool IsWindowHidden(void);
// æ£æ¥çªå£å½åæ¯å¦æå°å
RLAPI bool IsWindowMinimized(void);
// æ£æ¥çªå£å½åæ¯å¦æå¤§å
RLAPI bool IsWindowMaximized(void);
// æ£æ¥çªå£å½åæ¯å¦è·å¾ç¦ç¹
RLAPI bool IsWindowFocused(void);
// æ£æ¥çªå£å¨ä¸ä¸å¸§æ¯å¦è¢«è°æ´å¤§å°
RLAPI bool IsWindowResized(void);
// æ£æ¥æ¯å¦å¯ç¨äºä¸ä¸ªç¹å®ççªå£æ å¿
RLAPI bool IsWindowState(unsigned int flag);
// ä½¿ç¨æ å¿è®¾ç½®çªå£éç½®ç¶æ
RLAPI void SetWindowState(unsigned int flags);
// æ¸é¤çªå£éç½®ç¶ææ å¿
RLAPI void ClearWindowState(unsigned int flags);
// åæ¢çªå£ç¶æï¼å¨å±/çªå£æ¨¡å¼ï¼è°æ´æ¾ç¤ºå¨ä»¥å¹éçªå£åè¾¨ç
RLAPI void ToggleFullscreen(void);
// åæ¢çªå£ç¶æï¼æ è¾¹æ¡çªå£æ¨¡å¼ï¼è°æ´çªå£ä»¥å¹éæ¾ç¤ºå¨åè¾¨ç
RLAPI void ToggleBorderlessWindowed(void);
// è®¾ç½®çªå£ç¶æï¼æå¤§åï¼å¦æçªå£å¯è°æ´å¤§å°ï¼
RLAPI void MaximizeWindow(void);
// è®¾ç½®çªå£ç¶æï¼æå°åï¼å¦æçªå£å¯è°æ´å¤§å°ï¼
RLAPI void MinimizeWindow(void);
// è®¾ç½®çªå£ç¶æï¼éæå°å/æå¤§å
RLAPI void RestoreWindow(void);
// è®¾ç½®çªå£å¾æ ï¼åå¼ å¾åï¼RGBA 32ä½ï¼
RLAPI void SetWindowIcon(Image image);
// è®¾ç½®çªå£å¾æ ï¼å¤å¼ å¾åï¼RGBA 32ä½ï¼
RLAPI void SetWindowIcons(Image *images, int count);
// è®¾ç½®çªå£æ é¢
RLAPI void SetWindowTitle(const char *title);
// è®¾ç½®çªå£å¨å±å¹ä¸çä½ç½®
RLAPI void SetWindowPosition(int x, int y);
// è®¾ç½®å½åçªå£æå¨çæ¾ç¤ºå¨
RLAPI void SetWindowMonitor(int monitor);
// è®¾ç½®çªå£çæå°å°ºå¯¸ï¼éç¨äºå¯è°æ´å¤§å°ççªå£ï¼
RLAPI void SetWindowMinSize(int width, int height);
// è®¾ç½®çªå£çæå¤§å°ºå¯¸ï¼éç¨äºå¯è°æ´å¤§å°ççªå£ï¼
RLAPI void SetWindowMaxSize(int width, int height);
// è®¾ç½®çªå£å°ºå¯¸
RLAPI void SetWindowSize(int width, int height);
// è®¾ç½®çªå£éæåº¦ [0.0f..1.0f]
RLAPI void SetWindowOpacity(float opacity);
// è®¾ç½®çªå£è·å¾ç¦ç¹
RLAPI void SetWindowFocused(void);
// è·ååççªå£å¥æ
RLAPI void *GetWindowHandle(void);
// è·åå½åå±å¹å®½åº¦
RLAPI int GetScreenWidth(void);
// è·åå½åå±å¹é«åº¦
RLAPI int GetScreenHeight(void);
// è·åå½åæ¸²æå®½åº¦ï¼èèé«DPIï¼
RLAPI int GetRenderWidth(void);
// è·åå½åæ¸²æé«åº¦ï¼èèé«DPIï¼
RLAPI int GetRenderHeight(void);
// è·åè¿æ¥çæ¾ç¤ºå¨æ°é
RLAPI int GetMonitorCount(void);
// è·åçªå£æå¨çå½åæ¾ç¤ºå¨
RLAPI int GetCurrentMonitor(void);
// è·åæå®æ¾ç¤ºå¨çä½ç½®
RLAPI Vector2 GetMonitorPosition(int monitor);
// è·åæå®æ¾ç¤ºå¨çå®½åº¦ï¼æ¾ç¤ºå¨å½åä½¿ç¨çè§é¢æ¨¡å¼ï¼
RLAPI int GetMonitorWidth(int monitor);
// è·åæå®æ¾ç¤ºå¨çé«åº¦ï¼æ¾ç¤ºå¨å½åä½¿ç¨çè§é¢æ¨¡å¼ï¼
RLAPI int GetMonitorHeight(int monitor);
// è·åæå®æ¾ç¤ºå¨çç©çå®½åº¦ï¼æ¯«ç±³ï¼
RLAPI int GetMonitorPhysicalWidth(int monitor);
// è·åæå®æ¾ç¤ºå¨çç©çé«åº¦ï¼æ¯«ç±³ï¼
RLAPI int GetMonitorPhysicalHeight(int monitor);
// è·åæå®æ¾ç¤ºå¨çå·æ°ç
RLAPI int GetMonitorRefreshRate(int monitor);
// è·åçªå£å¨æ¾ç¤ºå¨ä¸çXYä½ç½®
RLAPI Vector2 GetWindowPosition(void);
// è·åçªå£çç¼©æ¾DPIå å­
RLAPI Vector2 GetWindowScaleDPI(void);
// è·åæå®æ¾ç¤ºå¨çå¯è¯»UTF-8ç¼ç åç§°
RLAPI const char *GetMonitorName(int monitor);
// è®¾ç½®åªè´´æ¿çææ¬åå®¹
RLAPI void SetClipboardText(const char *text);
// è·ååªè´´æ¿çææ¬åå®¹
RLAPI const char *GetClipboardText(void);
// è·ååªè´´æ¿çå¾ååå®¹
RLAPI Image GetClipboardImage(void);
// å¯ç¨å¨EndDrawing()æ¶ç­å¾äºä»¶ï¼ä¸èªå¨è½®è¯¢äºä»¶
RLAPI void EnableEventWaiting(void);
// ç¦ç¨å¨EndDrawing()æ¶ç­å¾äºä»¶ï¼èªå¨è½®è¯¢äºä»¶
RLAPI void DisableEventWaiting(void);

// ä¸åæ ç¸å³çå½æ°
RLAPI void ShowCursor(void);                                      // æ¾ç¤ºåæ 
RLAPI void HideCursor(void);                                      // éèåæ 
RLAPI bool IsCursorHidden(void);                                  // æ£æ¥åæ æ¯å¦ä¸å¯è§
RLAPI void EnableCursor(void);                                    // å¯ç¨åæ ï¼è§£éåæ ï¼
RLAPI void DisableCursor(void);                                   // ç¦ç¨åæ ï¼éå®åæ ï¼
RLAPI bool IsCursorOnScreen(void);                                // æ£æ¥åæ æ¯å¦å¨å±å¹ä¸

// ç»å¾ç¸å³å½æ°
RLAPI void ClearBackground(Color color);                          // è®¾ç½®èæ¯é¢è²ï¼å¸§ç¼å²åºæ¸é¤é¢è²ï¼
RLAPI void BeginDrawing(void);                                    // è®¾ç½®ç»å¸ï¼å¸§ç¼å²åºï¼ä»¥å¼å§ç»å¾
RLAPI void EndDrawing(void);                                      // ç»æç»å¸ç»å¾å¹¶äº¤æ¢ç¼å²åºï¼åç¼å²ï¼
RLAPI void BeginMode2D(Camera2D camera);                          // ä½¿ç¨èªå®ä¹ç¸æºå¼å§2Dæ¨¡å¼ç»å¾
RLAPI void EndMode2D(void);                                       // ç»æèªå®ä¹ç¸æºç2Dæ¨¡å¼ç»å¾
RLAPI void BeginMode3D(Camera3D camera);                          // ä½¿ç¨èªå®ä¹ç¸æºå¼å§3Dæ¨¡å¼ç»å¾
RLAPI void EndMode3D(void);                                       // ç»æ3Dæ¨¡å¼ç»å¾å¹¶è¿åé»è®¤ç2Dæ­£äº¤æ¨¡å¼
RLAPI void BeginTextureMode(RenderTexture2D target);              // å¼å§åæ¸²æçº¹çç»å¾
RLAPI void EndTextureMode(void);                                  // ç»æåæ¸²æçº¹çç»å¾
RLAPI void BeginShaderMode(Shader shader);                        // å¼å§ä½¿ç¨èªå®ä¹çè²å¨ç»å¾
RLAPI void EndShaderMode(void);                                   // ç»æèªå®ä¹çè²å¨ç»å¾ï¼ä½¿ç¨é»è®¤çè²å¨ï¼
RLAPI void BeginBlendMode(int mode);                              // å¼å§æ··åæ¨¡å¼ï¼alphaãå æ³ãä¹æ³ãåæ³ãèªå®ä¹ï¼
RLAPI void EndBlendMode(void);                                    // ç»ææ··åæ¨¡å¼ï¼éç½®ä¸ºé»è®¤ï¼alphaæ··åï¼
RLAPI void BeginScissorMode(int x, int y, int width, int height); // å¼å§è£åªæ¨¡å¼ï¼å®ä¹åç»­ç»å¾çå±å¹åºåï¼
RLAPI void EndScissorMode(void);                                  // ç»æè£åªæ¨¡å¼
RLAPI void BeginVrStereoMode(VrStereoConfig config);              // å¼å§ç«ä½æ¸²æï¼éè¦VRæ¨¡æå¨ï¼
RLAPI void EndVrStereoMode(void);                                 // ç»æç«ä½æ¸²æï¼éè¦VRæ¨¡æå¨ï¼

// VRæ¨¡æå¨çVRç«ä½éç½®å½æ°
// ä¸ºVRæ¨¡æå¨è®¾å¤åæ°å è½½VRç«ä½éç½®
RLAPI VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device);
// å¸è½½VRç«ä½éç½®
RLAPI void UnloadVrStereoConfig(VrStereoConfig config);

// çè²å¨ç®¡çå½æ°
// æ³¨æ: OpenGL 1.1 ä¸æ¯æçè²å¨åè½
// ä»æä»¶å è½½çè²å¨å¹¶ç»å®é»è®¤ä½ç½®
RLAPI Shader LoadShader(const char *vsFileName, const char *fsFileName);
// ä»ä»£ç å­ç¬¦ä¸²å è½½çè²å¨å¹¶ç»å®é»è®¤ä½ç½®
RLAPI Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode);
// æ£æ¥çè²å¨æ¯å¦ææï¼å·²å è½½å° GPUï¼
RLAPI bool IsShaderValid(Shader shader);
// è·åçè²å¨ç»ä¸åéçä½ç½®
RLAPI int GetShaderLocation(Shader shader, const char *uniformName);
// è·åçè²å¨å±æ§çä½ç½®
RLAPI int GetShaderLocationAttrib(Shader shader, const char *attribName);
// è®¾ç½®çè²å¨ç»ä¸åéçå¼
RLAPI void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType);
// è®¾ç½®çè²å¨ç»ä¸åéçå¼åé
RLAPI void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count);
// è®¾ç½®çè²å¨ç»ä¸åéçå¼ï¼4x4 ç©éµï¼
RLAPI void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat);
// è®¾ç½®çè²å¨ç»ä¸åéççº¹çå¼ï¼éæ ·å¨ 2Dï¼
RLAPI void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture);
// ä» GPU åå­ï¼VRAMï¼ä¸­å¸è½½çè²å¨
RLAPI void UnloadShader(Shader shader);

// ä¸å±å¹ç©ºé´ç¸å³çå½æ°
#define GetMouseRay GetScreenToWorldRay     // ä¸ºå¼å®¹æ§çæ¬ raylib çä»£ç æå·§
// ä»å±å¹ä½ç½®ï¼å¦é¼ æ ä½ç½®ï¼è·åä¸æ¡å°çº¿ï¼å³å°çº¿è¿½è¸ªï¼
RLAPI Ray GetScreenToWorldRay(Vector2 position, Camera camera);
// å¨è§å£åä»å±å¹ä½ç½®ï¼å¦é¼ æ ä½ç½®ï¼è·åä¸æ¡å°çº¿ï¼å³å°çº¿è¿½è¸ªï¼
RLAPI Ray GetScreenToWorldRayEx(Vector2 position, Camera camera, int width, int height);
// è·å 3D ä¸çç©ºé´ä½ç½®å¨å±å¹ç©ºé´ä¸­çä½ç½®
RLAPI Vector2 GetWorldToScreen(Vector3 position, Camera camera);
// è·å 3D ä¸çç©ºé´ä½ç½®å¨æå®è§å£å°ºå¯¸ä¸çå±å¹ç©ºé´ä½ç½®
RLAPI Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height);
// è·å 2D ç¸æºä¸çç©ºé´ä½ç½®å¨å±å¹ç©ºé´ä¸­çä½ç½®
RLAPI Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera);
// è·å 2D ç¸æºå±å¹ç©ºé´ä½ç½®å¨ä¸çç©ºé´ä¸­çä½ç½®
RLAPI Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera);
// è·åç¸æºçåæ¢ç©éµï¼è§å¾ç©éµï¼
RLAPI Matrix GetCameraMatrix(Camera camera);
// è·å 2D ç¸æºçåæ¢ç©éµ
RLAPI Matrix GetCameraMatrix2D(Camera2D camera);

// ä¸æ¶é´ç¸å³çå½æ°
RLAPI void SetTargetFPS(int fps);                                 // è®¾ç½®ç®æ å¸§çï¼æå¤§å¼ï¼
RLAPI float GetFrameTime(void);                                   // è·åä¸ä¸å¸§ç»å¶æç¨çæ¶é´ï¼ä»¥ç§ä¸ºåä½ï¼å³å¢éæ¶é´ï¼
RLAPI double GetTime(void);                                       // è·åèªInitWindow()è°ç¨ä»¥æ¥ç»è¿çæ¶é´ï¼ä»¥ç§ä¸ºåä½ï¼
RLAPI int GetFPS(void);                                           // è·åå½åå¸§ç

// èªå®ä¹å¸§æ§å¶å½æ°
// æ³¨æ: è¿äºå½æ°ä¾éè¦å®å¨æ§å¶å¸§å¤ççé«çº§ç¨æ·ä½¿ç¨
// é»è®¤æåµä¸ï¼EndDrawing() å®æä»¥ä¸å·¥ä½: ç»å¶ææåå®¹ + äº¤æ¢å±å¹ç¼å²åº + ç®¡çå¸§è®¡æ¶ + è½®è¯¢è¾å¥äºä»¶
// è¥è¦é¿åè¿ç§è¡ä¸ºå¹¶æå¨æ§å¶å¸§å¤çè¿ç¨ï¼è¯·å¨ config.h ä¸­å¯ç¨: SUPPORT_CUSTOM_FRAME_CONTROL
RLAPI void SwapScreenBuffer(void);                                // äº¤æ¢åç¼å²åºååç¼å²åºï¼å±å¹ç»å¶ï¼
RLAPI void PollInputEvents(void);                                 // æ³¨åææè¾å¥äºä»¶
RLAPI void WaitTime(double seconds);                              // ç­å¾ä¸æ®µæ¶é´ï¼æåç¨åºæ§è¡ï¼

// éæºå¼çæå½æ°
RLAPI void SetRandomSeed(unsigned int seed);                      // è®¾ç½®éæºæ°çæå¨çç§å­
RLAPI int GetRandomValue(int min, int max);                       // è·åä¸ä¸ªä»äº min å max ä¹é´çéæºå¼ï¼åå«ä¸¤ç«¯ï¼
RLAPI int *LoadRandomSequence(unsigned int count, int min, int max); // å è½½éæºå¼åºåï¼æ éå¤å¼
RLAPI void UnloadRandomSequence(int *sequence);                   // å¸è½½éæºå¼åºå

// æé¡¹å½æ°
RLAPI void TakeScreenshot(const char *fileName);                  // å¯¹å½åå±å¹è¿è¡æªå¾ï¼æä»¶åæ©å±åå®ä¹æ ¼å¼ï¼
RLAPI void SetConfigFlags(unsigned int flags);                    // è®¾ç½®åå§åéç½®æ å¿ï¼æ¥ç FLAGSï¼
RLAPI void OpenURL(const char *url);                              // ä½¿ç¨é»è®¤ç³»ç»æµè§å¨æå¼ URLï¼å¦æå¯ç¨ï¼

// æ³¨æ: ä»¥ä¸å½æ°å¨ [utils] æ¨¡åä¸­å®ç°
//------------------------------------------------------------------
RLAPI void TraceLog(int logLevel, const char *text, ...);         // æ¾ç¤ºè·è¸ªæ¥å¿æ¶æ¯ï¼LOG_DEBUGãLOG_INFOãLOG_WARNINGãLOG_ERROR ç­ï¼
RLAPI void SetTraceLogLevel(int logLevel);                        // è®¾ç½®å½åéå¼ï¼æä½ï¼æ¥å¿çº§å«
RLAPI void *MemAlloc(unsigned int size);                          // åé¨åå­åéå¨
RLAPI void *MemRealloc(void *ptr, unsigned int size);             // åé¨åå­éæ°åéå¨
RLAPI void MemFree(void *ptr);                                    // åé¨åå­éæ¾

// è®¾ç½®èªå®ä¹åè°å½æ°
// è­¦å: åè°å½æ°çè®¾ç½®ä»éç¨äºé«çº§ç¨æ·
RLAPI void SetTraceLogCallback(TraceLogCallback callback);         // è®¾ç½®èªå®ä¹è·è¸ªæ¥å¿åè°å½æ°
RLAPI void SetLoadFileDataCallback(LoadFileDataCallback callback); // è®¾ç½®èªå®ä¹æä»¶äºè¿å¶æ°æ®å è½½åè°å½æ°
RLAPI void SetSaveFileDataCallback(SaveFileDataCallback callback); // è®¾ç½®èªå®ä¹æä»¶äºè¿å¶æ°æ®ä¿å­åè°å½æ°
RLAPI void SetLoadFileTextCallback(LoadFileTextCallback callback); // è®¾ç½®èªå®ä¹æä»¶ææ¬æ°æ®å è½½åè°å½æ°
RLAPI void SetSaveFileTextCallback(SaveFileTextCallback callback); // è®¾ç½®èªå®ä¹æä»¶ææ¬æ°æ®ä¿å­åè°å½æ°

// æä»¶ç®¡çå½æ°
RLAPI unsigned char *LoadFileData(const char *fileName, int *dataSize); // ä»¥å­èæ°ç»å½¢å¼å è½½æä»¶æ°æ®ï¼è¯»åï¼
RLAPI void UnloadFileData(unsigned char *data);                   // å¸è½½ç±LoadFileData()åéçæä»¶æ°æ®
RLAPI bool SaveFileData(const char *fileName, void *data, int dataSize); // å°å­èæ°ç»ä¸­çæ°æ®ä¿å­å°æä»¶ï¼åå¥ï¼ï¼æåè¿åtrue
RLAPI bool ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName); // å°æ°æ®å¯¼åºä¸ºä»£ç æä»¶ï¼.hï¼ï¼æåè¿åtrue
RLAPI char *LoadFileText(const char *fileName);                   // ä»æä»¶ä¸­å è½½ææ¬æ°æ®ï¼è¯»åï¼ï¼è¿åä»¥'\0'ç»å°¾çå­ç¬¦ä¸²
RLAPI void UnloadFileText(char *text);                            // å¸è½½ç±LoadFileText()åéçæä»¶ææ¬æ°æ®
RLAPI bool SaveFileText(const char *fileName, char *text);        // å°ææ¬æ°æ®ä¿å­å°æä»¶ï¼åå¥ï¼ï¼å­ç¬¦ä¸²å¿é¡»ä»¥'\0'ç»å°¾ï¼æåè¿åtrue
//------------------------------------------------------------------

// æä»¶ç³»ç»å½æ°
RLAPI bool FileExists(const char *fileName);                      // æ£æ¥æä»¶æ¯å¦å­å¨
RLAPI bool DirectoryExists(const char *dirPath);                  // æ£æ¥ç®å½è·¯å¾æ¯å¦å­å¨
RLAPI bool IsFileExtension(const char *fileName, const char *ext); // æ£æ¥æä»¶æ©å±åï¼åæ¬ç¹å·ï¼.png, .wavï¼
RLAPI int GetFileLength(const char *fileName);                    // è·åæä»¶çå­èé¿åº¦ï¼æ³¨æ: GetFileSize()ä¸windows.hå²çªï¼
RLAPI const char *GetFileExtension(const char *fileName);         // è·åæä»¶åä¸­æ©å±åçæéï¼åæ¬ç¹å·: '.png'ï¼
RLAPI const char *GetFileName(const char *filePath);              // è·åè·¯å¾å­ç¬¦ä¸²ä¸­çæä»¶åæé
RLAPI const char *GetFileNameWithoutExt(const char *filePath);    // è·åä¸å¸¦æ©å±åçæä»¶åï¼ä½¿ç¨éæå­ç¬¦ä¸²ï¼
RLAPI const char *GetDirectoryPath(const char *filePath);         // è·ååå«è·¯å¾çæä»¶åçå®æ´è·¯å¾ï¼ä½¿ç¨éæå­ç¬¦ä¸²ï¼
RLAPI const char *GetPrevDirectoryPath(const char *dirPath);      // è·åç»å®è·¯å¾çä¸ä¸çº§ç®å½è·¯å¾ï¼ä½¿ç¨éæå­ç¬¦ä¸²ï¼
RLAPI const char *GetWorkingDirectory(void);                      // è·åå½åå·¥ä½ç®å½ï¼ä½¿ç¨éæå­ç¬¦ä¸²ï¼
RLAPI const char *GetApplicationDirectory(void);                  // è·åè¿è¡ä¸­åºç¨ç¨åºçç®å½ï¼ä½¿ç¨éæå­ç¬¦ä¸²ï¼
RLAPI int MakeDirectory(const char *dirPath);                     // åå»ºç®å½ï¼åæ¬è¯·æ±çå®æ´è·¯å¾ï¼ï¼æåè¿å0
RLAPI bool ChangeDirectory(const char *dir);                      // æ´æ¹å·¥ä½ç®å½ï¼æåè¿åtrue
RLAPI bool IsPathFile(const char *path);                          // æ£æ¥ç»å®è·¯å¾æ¯æä»¶è¿æ¯ç®å½
RLAPI bool IsFileNameValid(const char *fileName);                 // æ£æ¥æä»¶åæ¯å¦å¯¹å¹³å°/æä½ç³»ç»ææ
RLAPI FilePathList LoadDirectoryFiles(const char *dirPath);       // å è½½ç®å½ä¸­çæä»¶è·¯å¾
RLAPI FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs); // å è½½ç®å½ä¸­çæä»¶è·¯å¾ï¼å¹¶è¿è¡æ©å±åè¿æ»¤åéå½ç®å½æ«æãå¨è¿æ»¤å­ç¬¦ä¸²ä¸­ä½¿ç¨ 'DIR' å¯å°ç®å½åå«å¨ç»æä¸­
RLAPI void UnloadDirectoryFiles(FilePathList files);              // å¸è½½æä»¶è·¯å¾
RLAPI bool IsFileDropped(void);                                   // æ£æ¥æ¯å¦ææä»¶è¢«ææ¾å°çªå£ä¸­
RLAPI FilePathList LoadDroppedFiles(void);                        // å è½½è¢«ææ¾çæä»¶è·¯å¾
RLAPI void UnloadDroppedFiles(FilePathList files);                // å¸è½½è¢«ææ¾çæä»¶è·¯å¾
RLAPI long GetFileModTime(const char *fileName);                  // è·åæä»¶çä¿®æ¹æ¶é´ï¼æååå¥æ¶é´ï¼

// åç¼©/ç¼ç åè½
RLAPI unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize);        // åç¼©æ°æ®ï¼DEFLATEç®æ³ï¼ï¼åå­å¿é¡»ä½¿ç¨MemFree()éæ¾
RLAPI unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize);  // è§£åç¼©æ°æ®ï¼DEFLATEç®æ³ï¼ï¼åå­å¿é¡»ä½¿ç¨MemFree()éæ¾
RLAPI char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize);               // å°æ°æ®ç¼ç ä¸ºBase64å­ç¬¦ä¸²ï¼åå­å¿é¡»ä½¿ç¨MemFree()éæ¾
RLAPI unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize);                    // è§£ç Base64å­ç¬¦ä¸²æ°æ®ï¼åå­å¿é¡»ä½¿ç¨MemFree()éæ¾
RLAPI unsigned int ComputeCRC32(unsigned char *data, int dataSize);     // è®¡ç®CRC32åå¸ç 
RLAPI unsigned int *ComputeMD5(unsigned char *data, int dataSize);      // è®¡ç®MD5åå¸ç ï¼è¿åéæint[4]æ°ç»ï¼16å­èï¼
RLAPI unsigned int *ComputeSHA1(unsigned char *data, int dataSize);      // è®¡ç®SHA1åå¸ç ï¼è¿åéæint[5]æ°ç»ï¼20å­èï¼

// èªå¨åäºä»¶åè½
// ä»æä»¶å è½½èªå¨åäºä»¶åè¡¨ï¼è¥ä¼ å¥ NULL åè¿åç©ºåè¡¨ï¼å®¹éä¸º MAX_AUTOMATION_EVENTS
RLAPI AutomationEventList LoadAutomationEventList(const char *fileName);
// ä»æä»¶ä¸­å¸è½½èªå¨åäºä»¶åè¡¨
RLAPI void UnloadAutomationEventList(AutomationEventList list);
// å°èªå¨åäºä»¶åè¡¨å¯¼åºä¸ºææ¬æä»¶
RLAPI bool ExportAutomationEventList(AutomationEventList list, const char *fileName);
// è®¾ç½®è¦è®°å½çèªå¨åäºä»¶åè¡¨
RLAPI void SetAutomationEventList(AutomationEventList *list);
// è®¾ç½®èªå¨åäºä»¶åé¨çåºç¡å¸§ï¼å¼å§è®°å½
RLAPI void SetAutomationEventBaseFrame(int frame);
// å¼å§è®°å½èªå¨åäºä»¶ï¼å¿é¡»åè®¾ç½® AutomationEventListï¼
RLAPI void StartAutomationEventRecording(void);
// åæ­¢è®°å½èªå¨åäºä»¶
RLAPI void StopAutomationEventRecording(void);
// æ­æ¾å·²è®°å½çèªå¨åäºä»¶
RLAPI void PlayAutomationEvent(AutomationEvent event);
//------------------------------------------------------------------------------------

// è¾å¥å¤çå½æ° (æ¨¡å: core)
//------------------------------------------------------------------------------------

// ä¸è¾å¥ç¸å³çå½æ°ï¼é®ç
// æ£æ¥æä¸ªé®æ¯å¦è¢«æä¸ä¸æ¬¡
RLAPI bool IsKeyPressed(int key);                             
// æ£æ¥æä¸ªé®æ¯å¦åæ¬¡è¢«æä¸
RLAPI bool IsKeyPressedRepeat(int key);                       
// æ£æ¥æä¸ªé®æ¯å¦æ­£å¨è¢«æä¸
RLAPI bool IsKeyDown(int key);                                
// æ£æ¥æä¸ªé®æ¯å¦è¢«éæ¾ä¸æ¬¡
RLAPI bool IsKeyReleased(int key);                            
// æ£æ¥æä¸ªé®æ¯å¦æªè¢«æä¸
RLAPI bool IsKeyUp(int key);                                  
// è·åæä¸çé®ï¼é®ç ï¼ï¼å¤æ¬¡è°ç¨ä»¥å¤çæéçé®ï¼éåç©ºæ¶è¿å 0
RLAPI int GetKeyPressed(void);                                
// è·åæä¸çå­ç¬¦ï¼Unicodeï¼ï¼å¤æ¬¡è°ç¨ä»¥å¤çæéçå­ç¬¦ï¼éåç©ºæ¶è¿å 0
RLAPI int GetCharPressed(void);                               
// è®¾ç½®ä¸ä¸ªèªå®ä¹é®æ¥éåºç¨åºï¼é»è®¤æ¯ ESCï¼
RLAPI void SetExitKey(int key);                               

// ä¸è¾å¥ç¸å³çå½æ°ï¼æ¸¸æææ
// æ£æ¥æä¸ªæ¸¸ææææ¯å¦å¯ç¨
RLAPI bool IsGamepadAvailable(int gamepad);                                        
// è·åæ¸¸æææçåé¨åç§° ID
RLAPI const char *GetGamepadName(int gamepad);                                     
// æ£æ¥æ¸¸æææçæä¸ªæé®æ¯å¦è¢«æä¸ä¸æ¬¡
RLAPI bool IsGamepadButtonPressed(int gamepad, int button);                        
// æ£æ¥æ¸¸æææçæä¸ªæé®æ¯å¦æ­£å¨è¢«æä¸
RLAPI bool IsGamepadButtonDown(int gamepad, int button);                           
// æ£æ¥æ¸¸æææçæä¸ªæé®æ¯å¦è¢«éæ¾ä¸æ¬¡
RLAPI bool IsGamepadButtonReleased(int gamepad, int button);                       
// æ£æ¥æ¸¸æææçæä¸ªæé®æ¯å¦æªè¢«æä¸
RLAPI bool IsGamepadButtonUp(int gamepad, int button);                             
// è·åæåæä¸çæ¸¸ææææé®
RLAPI int GetGamepadButtonPressed(void);                                           
// è·åæä¸ªæ¸¸æææçè½´æ°é
RLAPI int GetGamepadAxisCount(int gamepad);                                        
// è·åæä¸ªæ¸¸æææçæä¸ªè½´çç§»å¨å¼
RLAPI float GetGamepadAxisMovement(int gamepad, int axis);                         
// è®¾ç½®åé¨æ¸¸ææææ å°ï¼SDL_GameControllerDBï¼
RLAPI int SetGamepadMappings(const char *mappings);                                
// è®¾ç½®æ¸¸æææä¸¤ä¸ªé©¬è¾¾çéå¨ï¼æç»­æ¶é´ä»¥ç§ä¸ºåä½ï¼
RLAPI void SetGamepadVibration(int gamepad, float leftMotor, float rightMotor, float duration); 

// ä¸è¾å¥ç¸å³çå½æ°ï¼é¼ æ 
// æ£æ¥æä¸ªé¼ æ æé®æ¯å¦è¢«æä¸ä¸æ¬¡
RLAPI bool IsMouseButtonPressed(int button);                  
// æ£æ¥æä¸ªé¼ æ æé®æ¯å¦æ­£å¨è¢«æä¸
RLAPI bool IsMouseButtonDown(int button);                     
// æ£æ¥æä¸ªé¼ æ æé®æ¯å¦è¢«éæ¾ä¸æ¬¡
RLAPI bool IsMouseButtonReleased(int button);                 
// æ£æ¥æä¸ªé¼ æ æé®æ¯å¦æªè¢«æä¸
RLAPI bool IsMouseButtonUp(int button);                       
// è·åé¼ æ ç X åæ 
RLAPI int GetMouseX(void);                                    
// è·åé¼ æ ç Y åæ 
RLAPI int GetMouseY(void);                                    
// è·åé¼ æ ç XY åæ 
RLAPI Vector2 GetMousePosition(void);                         
// è·åä¸¤å¸§ä¹é´é¼ æ çç§»å¨å¢é
RLAPI Vector2 GetMouseDelta(void);                            
// è®¾ç½®é¼ æ ç XY åæ 
RLAPI void SetMousePosition(int x, int y);                    
// è®¾ç½®é¼ æ çåç§»é
RLAPI void SetMouseOffset(int offsetX, int offsetY);          
// è®¾ç½®é¼ æ çç¼©æ¾æ¯ä¾
RLAPI void SetMouseScale(float scaleX, float scaleY);         
// è·åé¼ æ æ»è½®å¨ X æ Y æ¹åä¸çæå¤§ç§»å¨é
RLAPI float GetMouseWheelMove(void);                          
// è·åé¼ æ æ»è½®å¨ X å Y æ¹åä¸çç§»å¨é
RLAPI Vector2 GetMouseWheelMoveV(void);                       
// è®¾ç½®é¼ æ åæ æ ·å¼
RLAPI void SetMouseCursor(int cursor);                        

// ä¸è¾å¥ç¸å³çå½æ°ï¼è§¦æ¸
// è·åè§¦æ¸ç¹ 0 ç X åæ ï¼ç¸å¯¹äºå±å¹å°ºå¯¸ï¼
RLAPI int GetTouchX(void);                                    
// è·åè§¦æ¸ç¹ 0 ç Y åæ ï¼ç¸å¯¹äºå±å¹å°ºå¯¸ï¼
RLAPI int GetTouchY(void);                                    
// è·åæå®è§¦æ¸ç¹ç´¢å¼ç XY åæ ï¼ç¸å¯¹äºå±å¹å°ºå¯¸ï¼
RLAPI Vector2 GetTouchPosition(int index);                    
// è·åæå®ç´¢å¼çè§¦æ¸ç¹æ è¯ç¬¦
RLAPI int GetTouchPointId(int index);                         
// è·åè§¦æ¸ç¹çæ°é
RLAPI int GetTouchPointCount(void);

//------------------------------------------------------------------------------------
// æå¿åè§¦æ¸å¤çå½æ° (æ¨¡å: rgestures)
//------------------------------------------------------------------------------------
// ä½¿ç¨æ å¿å¯ç¨ä¸ç»æå¿
RLAPI void SetGesturesEnabled(unsigned int flags);
// æ£æ¥æ¯å¦æ£æµå°æä¸ªæå¿
RLAPI bool IsGestureDetected(unsigned int gesture);
// è·åææ°æ£æµå°çæå¿
RLAPI int GetGestureDetected(void);
// è·åæå¿æä½çæç»­æ¶é´ï¼ä»¥ç§ä¸ºåä½ï¼
RLAPI float GetGestureHoldDuration(void);
// è·åæå¿æå¨åé
RLAPI Vector2 GetGestureDragVector(void);
// è·åæå¿æå¨è§åº¦
RLAPI float GetGestureDragAngle(void);
// è·åæå¿æåçå¢é
RLAPI Vector2 GetGesturePinchVector(void);
// è·åæå¿æåè§åº¦
RLAPI float GetGesturePinchAngle(void);


// æ ·æ¡çº¿ç»å¶å½æ°
// ç»å¶çº¿æ§æ ·æ¡çº¿ï¼è³å°éè¦2ä¸ªç¹
RLAPI void DrawSplineLinear(const Vector2 *points, int pointCount, float thick, Color color);
// ç»å¶Bæ ·æ¡çº¿ï¼è³å°éè¦4ä¸ªç¹
RLAPI void DrawSplineBasis(const Vector2 *points, int pointCount, float thick, Color color);
// ç»å¶Catmull-Romæ ·æ¡çº¿ï¼è³å°éè¦4ä¸ªç¹
RLAPI void DrawSplineCatmullRom(const Vector2 *points, int pointCount, float thick, Color color);
// ç»å¶äºæ¬¡è´å¡å°æ ·æ¡çº¿ï¼è³å°éè¦3ä¸ªç¹ï¼1ä¸ªæ§å¶ç¹ï¼ï¼[p1, c2, p3, c4...]
RLAPI void DrawSplineBezierQuadratic(const Vector2 *points, int pointCount, float thick, Color color);
// ç»å¶ä¸æ¬¡è´å¡å°æ ·æ¡çº¿ï¼è³å°éè¦4ä¸ªç¹ï¼2ä¸ªæ§å¶ç¹ï¼ï¼[p1, c2, c3, p4, c5, c6...]
RLAPI void DrawSplineBezierCubic(const Vector2 *points, int pointCount, float thick, Color color);
// ç»å¶çº¿æ§æ ·æ¡çº¿æ®µï¼éè¦2ä¸ªç¹
RLAPI void DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color);
// ç»å¶Bæ ·æ¡çº¿æ®µï¼éè¦4ä¸ªç¹
RLAPI void DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color);
// ç»å¶Catmull-Romæ ·æ¡çº¿æ®µï¼éè¦4ä¸ªç¹
RLAPI void DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color);
// ç»å¶äºæ¬¡è´å¡å°æ ·æ¡çº¿æ®µï¼éè¦2ä¸ªç¹å1ä¸ªæ§å¶ç¹
RLAPI void DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color);
// ç»å¶ä¸æ¬¡è´å¡å°æ ·æ¡çº¿æ®µï¼éè¦2ä¸ªç¹å2ä¸ªæ§å¶ç¹
RLAPI void DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color);

// æ ·æ¡çº¿æ®µç¹è¯ä¼°å½æ°ï¼ç»å®tå¼èå´ä¸º [0.0f .. 1.0f]
// è·åï¼è¯ä¼°ï¼çº¿æ§æ ·æ¡çº¿ä¸çç¹
RLAPI Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, float t);
// è·åï¼è¯ä¼°ï¼Bæ ·æ¡çº¿ä¸çç¹
RLAPI Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);
// è·åï¼è¯ä¼°ï¼Catmull-Romæ ·æ¡çº¿ä¸çç¹
RLAPI Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);
// è·åï¼è¯ä¼°ï¼äºæ¬¡è´å¡å°æ ·æ¡çº¿ä¸çç¹
RLAPI Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t);
// è·åï¼è¯ä¼°ï¼ä¸æ¬¡è´å¡å°æ ·æ¡çº¿ä¸çç¹
RLAPI Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t);

// åºæ¬å½¢ç¶ç¢°ææ£æµå½æ°
// æ£æ¥ä¸¤ä¸ªç©å½¢ä¹é´æ¯å¦åçç¢°æ
RLAPI bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2);
// æ£æ¥ä¸¤ä¸ªåä¹é´æ¯å¦åçç¢°æ
RLAPI bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2);
// æ£æ¥ååç©å½¢ä¹é´æ¯å¦åçç¢°æ
RLAPI bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec);
// æ£æ¥åæ¯å¦ä¸ç±ä¸¤ç¹ [p1] å [p2] ææçç´çº¿åçç¢°æ
RLAPI bool CheckCollisionCircleLine(Vector2 center, float radius, Vector2 p1, Vector2 p2);
// æ£æ¥ç¹æ¯å¦å¨ç©å½¢åé¨
RLAPI bool CheckCollisionPointRec(Vector2 point, Rectangle rec);
// æ£æ¥ç¹æ¯å¦å¨ååé¨
RLAPI bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius);
// æ£æ¥ç¹æ¯å¦å¨ä¸è§å½¢åé¨
RLAPI bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3);
// æ£æ¥ç¹æ¯å¦å¨ç±ä¸¤ç¹ [p1] å [p2] ææçç´çº¿ä¸ï¼åè®¸ä¸å®çåç´ è¯¯å·® [threshold]
RLAPI bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold);
// æ£æ¥ç¹æ¯å¦å¨ç±é¡¶ç¹æ°ç»æè¿°çå¤è¾¹å½¢åé¨
RLAPI bool CheckCollisionPointPoly(Vector2 point, const Vector2 *points, int pointCount);
// æ£æ¥ç±ä¸¤ä¸ªç¹å®ä¹çä¸¤æ¡ç´çº¿æ¯å¦åçç¢°æï¼éè¿å¼ç¨è¿åç¢°æç¹
RLAPI bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint);
// è·åä¸¤ä¸ªç©å½¢ç¢°æåçéå ç©å½¢
RLAPI Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2);

//------------------------------------------------------------------------------------
// çº¹çå è½½åç»å¶å½æ° (æ¨¡å: çº¹ç)
//------------------------------------------------------------------------------------

// å¾åå è½½å½æ°
// æ³¨æ: è¿äºå½æ°ä¸éè¦GPUè®¿é®
RLAPI Image LoadImage(const char *fileName);                                                             // ä»æä»¶å è½½å¾åå°CPUåå­ (RAM)
RLAPI Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize);       // ä»åå§æä»¶æ°æ®å è½½å¾å
RLAPI Image LoadImageAnim(const char *fileName, int *frames);                                            // ä»æä»¶å è½½å¾ååºå (å¸§è¿½å å°image.data)
RLAPI Image LoadImageAnimFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int *frames); // ä»åå­ç¼å²åºå è½½å¾ååºå
RLAPI Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize);      // ä»åå­ç¼å²åºå è½½å¾åï¼fileTypeææä»¶æ©å±åï¼ä¾å¦: '.png'
RLAPI Image LoadImageFromTexture(Texture2D texture);                                                     // ä»GPUçº¹çæ°æ®å è½½å¾å
RLAPI Image LoadImageFromScreen(void);                                                                   // ä»å±å¹ç¼å²åºå è½½å¾å (æªå¾)
RLAPI bool IsImageValid(Image image);                                                                    // æ£æ¥å¾åæ¯å¦ææ (æ°æ®ååæ°)
RLAPI void UnloadImage(Image image);                                                                     // ä»CPUåå­ (RAM) å¸è½½å¾å
RLAPI bool ExportImage(Image image, const char *fileName);                                               // å°å¾åæ°æ®å¯¼åºå°æä»¶ï¼æåè¿åtrue
RLAPI unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize);              // å°å¾åå¯¼åºå°åå­ç¼å²åº
RLAPI bool ExportImageAsCode(Image image, const char *fileName);                                         // å°å¾åå¯¼åºä¸ºå®ä¹å­èæ°ç»çä»£ç æä»¶ï¼æåè¿åtrue

// å¾åçæå½æ°
RLAPI Image GenImageColor(int width, int height, Color color);                                           // çæå¾å: çº¯è²
RLAPI Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end);        // çæå¾å: çº¿æ§æ¸åï¼æ¹åä¸ºåº¦æ° [0..360]ï¼0=åç´æ¸å
RLAPI Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer);      // çæå¾å: å¾åæ¸å
RLAPI Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer);      // çæå¾å: æ¹å½¢æ¸å
RLAPI Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2);    // çæå¾å: æ£çæ ¼
RLAPI Image GenImageWhiteNoise(int width, int height, float factor);                                     // çæå¾å: ç½åªå£°
RLAPI Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale);           // çæå¾å: ææåªå£°
RLAPI Image GenImageCellular(int width, int height, int tileSize);                                       // çæå¾å: ç»èç®æ³ï¼æ´å¤§çtileSizeæå³çæ´å¤§çç»è
RLAPI Image GenImageText(int width, int height, const char *text);                                       // çæå¾å: ä»ææ¬æ°æ®çæç°åº¦å¾å

// å¾åæä½å½æ°
RLAPI Image ImageCopy(Image image);                                                                      // åå»ºå¾åå¯æ¬ (ç¨äºåæ¢æä½)
RLAPI Image ImageFromImage(Image image, Rectangle rec);                                                  // ä»å¦ä¸ä¸ªå¾åçä¸é¨ååå»ºå¾å
RLAPI Image ImageFromChannel(Image image, int selectedChannel);                                          // ä»å¦ä¸ä¸ªå¾åçéå®ééåå»ºå¾å (ç°åº¦å¾)
RLAPI Image ImageText(const char *text, int fontSize, Color color);                                      // ä»ææ¬åå»ºå¾å (é»è®¤å­ä½)
RLAPI Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint);         // ä»ææ¬åå»ºå¾å (èªå®ä¹ç²¾çµå­ä½)
RLAPI void ImageFormat(Image *image, int newFormat);                                                     // å°å¾åæ°æ®è½¬æ¢ä¸ºæéæ ¼å¼
RLAPI void ImageToPOT(Image *image, Color fill);                                                         // å°å¾åè½¬æ¢ä¸º2çå¹æ¬¡æ¹å¤§å° (POT)
RLAPI void ImageCrop(Image *image, Rectangle crop);                                                      // å°å¾åè£åªå°å®ä¹çç©å½¢
RLAPI void ImageAlphaCrop(Image *image, float threshold);                                                // æ ¹æ®alphaå¼è£åªå¾å
RLAPI void ImageAlphaClear(Image *image, Color color, float threshold);                                  // å°alphaééæ¸é¤ä¸ºæéé¢è²
RLAPI void ImageAlphaMask(Image *image, Image alphaMask);                                                // å¯¹å¾ååºç¨alphaé®ç½©
RLAPI void ImageAlphaPremultiply(Image *image);                                                          // é¢ä¹alphaéé
RLAPI void ImageBlurGaussian(Image *image, int blurSize);                                                // ä½¿ç¨çå¼æ¨¡ç³è¿ä¼¼åºç¨é«æ¯æ¨¡ç³
RLAPI void ImageKernelConvolution(Image *image, const float *kernel, int kernelSize);                    // å¯¹å¾ååºç¨èªå®ä¹æ¹å½¢å·ç§¯æ ¸
RLAPI void ImageResize(Image *image, int newWidth, int newHeight);                                       // è°æ´å¾åå¤§å° (åä¸æ¬¡ç¼©æ¾ç®æ³)
RLAPI void ImageResizeNN(Image *image, int newWidth,int newHeight);                                      // è°æ´å¾åå¤§å° (æè¿é»ç¼©æ¾ç®æ³)
RLAPI void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill); // è°æ´ç»å¸å¤§å°å¹¶ç¨é¢è²å¡«å
RLAPI void ImageMipmaps(Image *image);                                                                   // ä¸ºæä¾çå¾åè®¡ç®ææmipmapçº§å«
RLAPI void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp);                            // å°å¾åæ°æ®æå¨å°16ä½ææ´ä½ (Floyd-Steinbergæå¨)
RLAPI void ImageFlipVertical(Image *image);                                                              // åç´ç¿»è½¬å¾å
RLAPI void ImageFlipHorizontal(Image *image);                                                            // æ°´å¹³ç¿»è½¬å¾å
RLAPI void ImageRotate(Image *image, int degrees);                                                       // æè¾å¥è§åº¦æè½¬å¾å (åº¦æ° -359 å° 359)
RLAPI void ImageRotateCW(Image *image);                                                                  // é¡ºæ¶éæè½¬å¾å90åº¦
RLAPI void ImageRotateCCW(Image *image);                                                                 // éæ¶éæè½¬å¾å90åº¦
RLAPI void ImageColorTint(Image *image, Color color);                                                    // ä¿®æ¹å¾åé¢è²: çè²
RLAPI void ImageColorInvert(Image *image);                                                               // ä¿®æ¹å¾åé¢è²: åè½¬
RLAPI void ImageColorGrayscale(Image *image);                                                            // ä¿®æ¹å¾åé¢è²: ç°åº¦å
RLAPI void ImageColorContrast(Image *image, float contrast);                                             // ä¿®æ¹å¾åé¢è²: å¯¹æ¯åº¦ (-100 å° 100)
RLAPI void ImageColorBrightness(Image *image, int brightness);                                           // ä¿®æ¹å¾åé¢è²: äº®åº¦ (-255 å° 255)
RLAPI void ImageColorReplace(Image *image, Color color, Color replace);                                  // ä¿®æ¹å¾åé¢è²: æ¿æ¢é¢è²
RLAPI Color *LoadImageColors(Image image);                                                               // ä»å¾åå è½½é¢è²æ°æ®ä½ä¸ºColoræ°ç» (RGBA - 32ä½)
RLAPI Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount);                         // ä»å¾åå è½½é¢è²è°è²æ¿ä½ä¸ºColoræ°ç» (RGBA - 32ä½)
RLAPI void UnloadImageColors(Color *colors);                                                             // å¸è½½ä½¿ç¨LoadImageColors()å è½½çé¢è²æ°æ®
RLAPI void UnloadImagePalette(Color *colors);                                                            // å¸è½½ä½¿ç¨LoadImagePalette()å è½½çé¢è²è°è²æ¿
RLAPI Rectangle GetImageAlphaBorder(Image image, float threshold);                                       // è·åå¾åalphaè¾¹çç©å½¢
RLAPI Color GetImageColor(Image image, int x, int y);                                                    // è·åå¾åå¨ (x, y) ä½ç½®çåç´ é¢è²

// å¾åç»å¶å½æ°
// æ³¨æ: å¾åè½¯ä»¶æ¸²æå½æ° (CPU)
RLAPI void ImageClearBackground(Image *dst, Color color);                                                // ç¨ç»å®é¢è²æ¸é¤å¾åèæ¯
RLAPI void ImageDrawPixel(Image *dst, int posX, int posY, Color color);                                  // å¨å¾ååç»å¶åç´ 
RLAPI void ImageDrawPixelV(Image *dst, Vector2 position, Color color);                                   // å¨å¾ååç»å¶åç´  (åéçæ¬)
RLAPI void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color); // å¨å¾ååç»å¶çº¿æ¡
RLAPI void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color);                          // å¨å¾ååç»å¶çº¿æ¡ (åéçæ¬)
RLAPI void ImageDrawLineEx(Image *dst, Vector2 start, Vector2 end, int thick, Color color);              // å¨å¾ååç»å¶å®ä¹ååº¦ççº¿æ¡
RLAPI void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color);               // å¨å¾ååç»å¶å¡«åçåå½¢
RLAPI void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color);                        // å¨å¾ååç»å¶å¡«åçåå½¢ (åéçæ¬)
RLAPI void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color);          // å¨å¾ååç»å¶åå½¢è½®å»
RLAPI void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color);                   // å¨å¾ååç»å¶åå½¢è½®å» (åéçæ¬)
RLAPI void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color);       // å¨å¾ååç»å¶ç©å½¢
RLAPI void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color);                 // å¨å¾ååç»å¶ç©å½¢ (åéçæ¬)
RLAPI void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color);                                // å¨å¾ååç»å¶ç©å½¢
RLAPI void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color);                   // å¨å¾ååç»å¶ç©å½¢çº¿æ¡
RLAPI void ImageDrawTriangle(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color color);               // å¨å¾ååç»å¶ä¸è§å½¢
RLAPI void ImageDrawTriangleEx(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color c1, Color c2, Color c3); // å¨å¾ååç»å¶å¸¦ææå¼é¢è²çä¸è§å½¢
RLAPI void ImageDrawTriangleLines(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color color);          // å¨å¾ååç»å¶ä¸è§å½¢è½®å»
RLAPI void ImageDrawTriangleFan(Image *dst, Vector2 *points, int pointCount, Color color);               // å¨å¾ååç»å¶ç±ç¹å®ä¹çä¸è§å½¢æ (ç¬¬ä¸ä¸ªé¡¶ç¹æ¯ä¸­å¿)
RLAPI void ImageDrawTriangleStrip(Image *dst, Vector2 *points, int pointCount, Color color);             // å¨å¾ååç»å¶ç±ç¹å®ä¹çä¸è§å½¢æ¡å¸¦
RLAPI void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint);             // å¨ç®æ å¾ååç»å¶æºå¾å (å¯¹æºå¾ååºç¨è²è°)
RLAPI void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color);   // å¨å¾å (ç®æ ) åç»å¶ææ¬ (ä½¿ç¨é»è®¤å­ä½)
RLAPI void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint); // å¨å¾å (ç®æ ) åç»å¶ææ¬ (èªå®ä¹ç²¾çµå­ä½)

// çº¹çå è½½å½æ°
// æ³¨æ: è¿äºå½æ°éè¦è®¿é®GPU
RLAPI Texture2D LoadTexture(const char *fileName);                                                       // ä»æä»¶å è½½çº¹çå°GPUåå­ (VRAM)
RLAPI Texture2D LoadTextureFromImage(Image image);                                                       // ä»å¾åæ°æ®å è½½çº¹ç
RLAPI TextureCubemap LoadTextureCubemap(Image image, int layout);                                        // ä»å¾åå è½½ç«æ¹ä½è´´å¾ï¼æ¯æå¤ç§å¾åç«æ¹ä½è´´å¾å¸å±
RLAPI RenderTexture2D LoadRenderTexture(int width, int height);                                          // å è½½ç¨äºæ¸²æççº¹ç (å¸§ç¼å²åº)
RLAPI bool IsTextureValid(Texture2D texture);                                                            // æ£æ¥çº¹çæ¯å¦ææ (å·²å è½½å°GPU)
RLAPI void UnloadTexture(Texture2D texture);                                                             // ä»GPUåå­ (VRAM) å¸è½½çº¹ç
RLAPI bool IsRenderTextureValid(RenderTexture2D target);                                                 // æ£æ¥æ¸²æçº¹çæ¯å¦ææ (å·²å è½½å°GPU)
RLAPI void UnloadRenderTexture(RenderTexture2D target);                                                  // ä»GPUåå­ (VRAM) å¸è½½æ¸²æçº¹ç
RLAPI void UpdateTexture(Texture2D texture, const void *pixels);                                         // ç¨æ°æ°æ®æ´æ°GPUçº¹ç
RLAPI void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels);                       // ç¨æ°æ°æ®æ´æ°GPUçº¹ççç©å½¢åºå

// çº¹çéç½®å½æ°
RLAPI void GenTextureMipmaps(Texture2D *texture);                                                        // ä¸ºçº¹ççæGPUå¤çº§æ¸è¿çº¹ç
RLAPI void SetTextureFilter(Texture2D texture, int filter);                                              // è®¾ç½®çº¹çç¼©æ¾è¿æ»¤æ¨¡å¼
RLAPI void SetTextureWrap(Texture2D texture, int wrap);                                                  // è®¾ç½®çº¹çç¯ç»æ¨¡å¼

// çº¹çç»å¶å½æ°
RLAPI void DrawTexture(Texture2D texture, int posX, int posY, Color tint);                               // ç»å¶ä¸ä¸ªTexture2D
RLAPI void DrawTextureV(Texture2D texture, Vector2 position, Color tint);                                // ä»¥Vector2å®ä¹çä½ç½®ç»å¶ä¸ä¸ªTexture2D
RLAPI void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint);  // ç¨æ©å±åæ°ç»å¶ä¸ä¸ªTexture2D
RLAPI void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint);            // ç»å¶ç±ç©å½¢å®ä¹ççº¹ççä¸é¨å
RLAPI void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint); // ç¨'pro'åæ°ç»å¶ç±ç©å½¢å®ä¹ççº¹ççä¸é¨å
RLAPI void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint); // ç»å¶ä¸ä¸ªå¯ä»¥å¾å¥½å°æä¼¸ææ¶ç¼©ççº¹çï¼æå¶ä¸é¨åï¼

// é¢è²/åç´ ç¸å³å½æ°
// æ£æ¥ä¸¤ç§é¢è²æ¯å¦ç¸ç­
RLAPI bool ColorIsEqual(Color col1, Color col2);
// è·ååºç¨äºéæåº¦çé¢è²ï¼éæåº¦åå¼èå´ä¸º 0.0f å° 1.0f
RLAPI Color Fade(Color color, float alpha);
// è·åé¢è²çåå­è¿å¶å¼ (0xRRGGBBAA)
RLAPI int ColorToInt(Color color);
// è·åé¢è²å½ä¸ååçæµ®ç¹å¼ [0..1]
RLAPI Vector4 ColorNormalize(Color color);
// ä»å½ä¸åçå¼ [0..1] è·åé¢è²
RLAPI Color ColorFromNormalized(Vector4 normalized);
// è·åé¢è²ç HSV å¼ï¼è²è° [0..360]ï¼é¥±ååº¦/æåº¦ [0..1]
RLAPI Vector3 ColorToHSV(Color color);
// ä» HSV å¼è·åé¢è²ï¼è²è° [0..360]ï¼é¥±ååº¦/æåº¦ [0..1]
RLAPI Color ColorFromHSV(float hue, float saturation, float value);
// è·åä¸å¦ä¸ç§é¢è²ç¸ä¹åçé¢è²
RLAPI Color ColorTint(Color color, Color tint);
// è·åç»è¿äº®åº¦æ ¡æ­£åçé¢è²ï¼äº®åº¦å å­åå¼èå´ä¸º -1.0f å° 1.0f
RLAPI Color ColorBrightness(Color color, float factor);
// è·åç»è¿å¯¹æ¯åº¦æ ¡æ­£åçé¢è²ï¼å¯¹æ¯åº¦å¼ä»äº -1.0f å 1.0f ä¹é´
RLAPI Color ColorContrast(Color color, float contrast);
// è·ååºç¨äºéæåº¦çé¢è²ï¼éæåº¦åå¼èå´ä¸º 0.0f å° 1.0f
RLAPI Color ColorAlpha(Color color, float alpha);
// è·åæºé¢è²ä»¥æå®è²è°ä¸ç®æ é¢è²è¿è¡ alpha æ··ååçé¢è²
RLAPI Color ColorAlphaBlend(Color dst, Color src, Color tint);
// è·åä¸¤ç§é¢è²ä¹é´ççº¿æ§æå¼é¢è²ï¼æå¼å å­ [0.0f..1.0f]
RLAPI Color ColorLerp(Color color1, Color color2, float factor);
// ä»åå­è¿å¶å¼è·åé¢è²ç»æä½
RLAPI Color GetColor(unsigned int hexValue);
// ä»ç¹å®æ ¼å¼çæºåç´ æéè·åé¢è²
RLAPI Color GetPixelColor(void *srcPtr, int format);
// å°æ ¼å¼ååçé¢è²è®¾ç½®å°ç®æ åç´ æé
RLAPI void SetPixelColor(void *dstPtr, Color color, int format);
// è·åç¹å®æ ¼å¼çåç´ æ°æ®å¤§å°ï¼ä»¥å­èä¸ºåä½ï¼
RLAPI int GetPixelDataSize(int width, int height, int format);


//------------------------------------------------------------------------------------
// å­ä½å è½½åææ¬ç»å¶å½æ° (æ¨¡å: ææ¬)
//------------------------------------------------------------------------------------

// å­ä½å è½½/å¸è½½å½æ°
// è·åé»è®¤å­ä½
RLAPI Font GetFontDefault(void);
// ä»æä»¶å è½½å­ä½å°GPUåå­ (VRAM)
RLAPI Font LoadFont(const char *fileName);
// ä»æä»¶å è½½å­ä½å¹¶å¸¦ææ©å±åæ°ï¼è¥codepointsä¸ºNULLä¸codepointCountä¸º0åå è½½é»è®¤å­ç¬¦éï¼å­ä½å¤§å°ä»¥åç´ é«åº¦æä¾
RLAPI Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount);
// ä»å¾åå è½½å­ä½ (XNAé£æ ¼)
RLAPI Font LoadFontFromImage(Image image, Color key, int firstChar);
// ä»åå­ç¼å²åºå è½½å­ä½ï¼fileTypeææä»¶æ©å±åï¼ä¾å¦: '.ttf'
RLAPI Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount);
// æ£æ¥å­ä½æ¯å¦ææ (å­ä½æ°æ®å·²å è½½ï¼è­¦å: æªæ£æ¥GPUçº¹ç)
RLAPI bool IsFontValid(Font font);
// å è½½å­ä½æ°æ®ä»¥ä¾åç»­ä½¿ç¨
RLAPI GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type);
// ä½¿ç¨å­ç¬¦ä¿¡æ¯çæå¾åå­ä½å¾é
RLAPI Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod);
// å¸è½½å­ä½å­ç¬¦ä¿¡æ¯æ°æ® (RAM)
RLAPI void UnloadFontData(GlyphInfo *glyphs, int glyphCount);
// ä»GPUåå­ (VRAM) å¸è½½å­ä½
RLAPI void UnloadFont(Font font);
// å°å­ä½å¯¼åºä¸ºä»£ç æä»¶ï¼æåè¿åtrue
RLAPI bool ExportFontAsCode(Font font, const char *fileName);

// ææ¬ç»å¶å½æ°
// ç»å¶å½åå¸§ç
RLAPI void DrawFPS(int posX, int posY);
// ç»å¶ææ¬ (ä½¿ç¨é»è®¤å­ä½)
RLAPI void DrawText(const char *text, int posX, int posY, int fontSize, Color color);
// ä½¿ç¨å­ä½åéå åæ°ç»å¶ææ¬
RLAPI void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint);
// ä½¿ç¨å­ä½åä¸ä¸åæ° (æè½¬) ç»å¶ææ¬
RLAPI void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint);
// ç»å¶ä¸ä¸ªå­ç¬¦ (ä»£ç ç¹)
RLAPI void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint);
// ç»å¶å¤ä¸ªå­ç¬¦ (ä»£ç ç¹)
RLAPI void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint);

// ææ¬å­ä½ä¿¡æ¯å½æ°
// è®¾ç½®ç»å¶å¸¦æ¢è¡ç¬¦ææ¬æ¶çåç´è¡é´è·
RLAPI void SetTextLineSpacing(int spacing);
// æµéé»è®¤å­ä½ä¸å­ç¬¦ä¸²çå®½åº¦
RLAPI int MeasureText(const char *text, int fontSize);
// æµéæå®å­ä½ä¸å­ç¬¦ä¸²çå¤§å°
RLAPI Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing);
// è·åå­ä½ä¸­ä»£ç ç¹ (Unicodeå­ç¬¦) çå­å½¢ç´¢å¼ä½ç½®ï¼è¥æªæ¾å°ååéå° '?'
RLAPI int GetGlyphIndex(Font font, int codepoint);
// è·åå­ä½ä¸­ä»£ç ç¹ (Unicodeå­ç¬¦) çå­å½¢ä¿¡æ¯æ°æ®ï¼è¥æªæ¾å°ååéå° '?'
RLAPI GlyphInfo GetGlyphInfo(Font font, int codepoint);
// è·åå­ä½å¾éä¸­ä»£ç ç¹ (Unicodeå­ç¬¦) çå­å½¢ç©å½¢ï¼è¥æªæ¾å°ååéå° '?'
RLAPI Rectangle GetGlyphAtlasRec(Font font, int codepoint);

// ææ¬ä»£ç ç¹ç®¡çå½æ° (Unicodeå­ç¬¦)
// ä»ä»£ç ç¹æ°ç»å è½½UTF-8ç¼ç çææ¬
RLAPI char *LoadUTF8(const int *codepoints, int length);
// å¸è½½ä»ä»£ç ç¹æ°ç»ç¼ç çUTF-8ææ¬
RLAPI void UnloadUTF8(char *text);
// ä»UTF-8ææ¬å­ç¬¦ä¸²å è½½ææä»£ç ç¹ï¼ä»£ç ç¹æ°ééè¿åæ°è¿å
RLAPI int *LoadCodepoints(const char *text, int *count);
// ä»åå­ä¸­å¸è½½ä»£ç ç¹æ°æ®
RLAPI void UnloadCodepoints(int *codepoints);
// è·åUTF-8ç¼ç å­ç¬¦ä¸²ä¸­çä»£ç ç¹æ»æ°
RLAPI int GetCodepointCount(const char *text);
// è·åUTF-8ç¼ç å­ç¬¦ä¸²ä¸­çä¸ä¸ä¸ªä»£ç ç¹ï¼å¤±è´¥æ¶è¿å 0x3f('?')
RLAPI int GetCodepoint(const char *text, int *codepointSize);
// è·åUTF-8ç¼ç å­ç¬¦ä¸²ä¸­çä¸ä¸ä¸ªä»£ç ç¹ï¼å¤±è´¥æ¶è¿å 0x3f('?')
RLAPI int GetCodepointNext(const char *text, int *codepointSize);
// è·åUTF-8ç¼ç å­ç¬¦ä¸²ä¸­çä¸ä¸ä¸ªä»£ç ç¹ï¼å¤±è´¥æ¶è¿å 0x3f('?')
RLAPI int GetCodepointPrevious(const char *text, int *codepointSize);
// å°ä¸ä¸ªä»£ç ç¹ç¼ç ä¸ºUTF-8å­èæ°ç» (æ°ç»é¿åº¦ä½ä¸ºåæ°è¿å)
RLAPI const char *CodepointToUTF8(int codepoint, int *utf8Size);

// ææ¬å­ç¬¦ä¸²ç®¡çå½æ° (éUTF-8å­ç¬¦ä¸²ï¼ä»å­èå­ç¬¦)
// æ³¨æ: æäºå­ç¬¦ä¸²ä¼å¨åé¨ä¸ºè¿åçå­ç¬¦ä¸²åéåå­ï¼è¯·å°å¿ä½¿ç¨!
// å°ä¸ä¸ªå­ç¬¦ä¸²å¤å¶å°å¦ä¸ä¸ªå­ç¬¦ä¸²ï¼è¿åå¤å¶çå­èæ°
RLAPI int TextCopy(char *dst, const char *src);
// æ£æ¥ä¸¤ä¸ªææ¬å­ç¬¦ä¸²æ¯å¦ç¸ç­
RLAPI bool TextIsEqual(const char *text1, const char *text2);
// è·åææ¬é¿åº¦ï¼æ£æ¥ '\0' ç»å°¾
RLAPI unsigned int TextLength(const char *text);
// ç¨åéè¿è¡ææ¬æ ¼å¼å (sprintf() é£æ ¼)
RLAPI const char *TextFormat(const char *text, ...);
// è·åææ¬å­ç¬¦ä¸²çä¸é¨å
RLAPI const char *TextSubtext(const char *text, int position, int length);
// æ¿æ¢ææ¬å­ç¬¦ä¸² (è­¦å: å¿é¡»éæ¾åå­!)
RLAPI char *TextReplace(const char *text, const char *replace, const char *by);
// å¨æå®ä½ç½®æå¥ææ¬ (è­¦å: å¿é¡»éæ¾åå­!)
RLAPI char *TextInsert(const char *text, const char *insert, int position);
// ç¨åéç¬¦è¿æ¥ææ¬å­ç¬¦ä¸²
RLAPI const char *TextJoin(const char **textList, int count, const char *delimiter);
// å°ææ¬æåä¸ºå¤ä¸ªå­ç¬¦ä¸²
RLAPI const char **TextSplit(const char *text, char delimiter, int *count);
// å¨ç¹å®ä½ç½®è¿½å ææ¬å¹¶ç§»å¨åæ !
RLAPI void TextAppend(char *text, const char *append, int *position);
// å¨å­ç¬¦ä¸²ä¸­æ¥æ¾ç¬¬ä¸ä¸ªææ¬åºç°çä½ç½®
RLAPI int TextFindIndex(const char *text, const char *find);
// è·åæä¾å­ç¬¦ä¸²çå¤§åçæ¬
RLAPI const char *TextToUpper(const char *text);
// è·åæä¾å­ç¬¦ä¸²çå°åçæ¬
RLAPI const char *TextToLower(const char *text);
// è·åæä¾å­ç¬¦ä¸²çå¸æ¯å¡å½åæ³çæ¬
RLAPI const char *TextToPascal(const char *text);
// è·åæä¾å­ç¬¦ä¸²çèå½¢å½åæ³çæ¬
RLAPI const char *TextToSnake(const char *text);
// è·åæä¾å­ç¬¦ä¸²çé©¼å³°å½åæ³çæ¬
RLAPI const char *TextToCamel(const char *text);
// ä»ææ¬ä¸­è·åæ´æ°å¼ (ä¸æ¯æè´å¼)
RLAPI int TextToInteger(const char *text);
// ä»ææ¬ä¸­è·åæµ®ç¹æ°å¼ (ä¸æ¯æè´å¼)
RLAPI float TextToFloat(const char *text);


//------------------------------------------------------------------------------------
// åºç¡3Då½¢ç¶ç»å¶å½æ° (æ¨¡å: æ¨¡å)
//------------------------------------------------------------------------------------

// åºç¡å ä½3Då½¢ç¶ç»å¶å½æ°
// å¨3Dä¸çç©ºé´ä¸­ç»å¶ä¸æ¡çº¿
RLAPI void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color);
// å¨3Dç©ºé´ä¸­ç»å¶ä¸ä¸ªç¹ï¼å®éä¸æ¯ä¸æ¡å°çº¿æ®µ
RLAPI void DrawPoint3D(Vector3 position, Color color);
// å¨3Dä¸çç©ºé´ä¸­ç»å¶ä¸ä¸ªå
RLAPI void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color);
// ç»å¶ä¸ä¸ªå¡«åé¢è²çä¸è§å½¢ï¼é¡¶ç¹æéæ¶éé¡ºåºæåï¼ï¼
RLAPI void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color);
// ç»å¶ç±ç¹å®ä¹çä¸è§å½¢æ¡å¸¦
RLAPI void DrawTriangleStrip3D(const Vector3 *points, int pointCount, Color color);
// ç»å¶ç«æ¹ä½
RLAPI void DrawCube(Vector3 position, float width, float height, float length, Color color);
// ç»å¶ç«æ¹ä½ï¼åéçæ¬ï¼
RLAPI void DrawCubeV(Vector3 position, Vector3 size, Color color);
// ç»å¶ç«æ¹ä½ççº¿æ¡
RLAPI void DrawCubeWires(Vector3 position, float width, float height, float length, Color color);
// ç»å¶ç«æ¹ä½ççº¿æ¡ï¼åéçæ¬ï¼
RLAPI void DrawCubeWiresV(Vector3 position, Vector3 size, Color color);
// ç»å¶çä½
RLAPI void DrawSphere(Vector3 centerPos, float radius, Color color);
// ç»å¶å·ææ©å±åæ°ççä½
RLAPI void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color);
// ç»å¶çä½ççº¿æ¡
RLAPI void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color);
// ç»å¶åæ±ä½/åé¥ä½
RLAPI void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color);
// ç»å¶ä¸ä¸ªåæ±ä½ï¼åºé¢å¨startPosï¼é¡¶é¢å¨endPos
RLAPI void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color);
// ç»å¶åæ±ä½/åé¥ä½ççº¿æ¡
RLAPI void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color);
// ç»å¶ä¸ä¸ªåæ±ä½ççº¿æ¡ï¼åºé¢å¨startPosï¼é¡¶é¢å¨endPos
RLAPI void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color);
// ç»å¶ä¸ä¸ªè¶åä½ï¼å¶çå½¢å¸½çä¸­å¿åå«å¨startPosåendPos
RLAPI void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color);
// ç»å¶è¶åä½ççº¿æ¡ï¼å¶çå½¢å¸½çä¸­å¿åå«å¨startPosåendPos
RLAPI void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color);
// ç»å¶ä¸ä¸ªXZå¹³é¢
RLAPI void DrawPlane(Vector3 centerPos, Vector2 size, Color color);
// ç»å¶ä¸æ¡å°çº¿
RLAPI void DrawRay(Ray ray, Color color);
// ç»å¶ä¸ä¸ªç½æ ¼ï¼ä»¥(0, 0, 0)ä¸ºä¸­å¿ï¼
RLAPI void DrawGrid(int slices, float spacing);

//------------------------------------------------------------------------------------
// 3Dæ¨¡åå è½½åç»å¶å½æ° (æ¨¡å: models)
//------------------------------------------------------------------------------------

// æ¨¡åç®¡çå½æ°
// ä»æä»¶å è½½æ¨¡åï¼ç½æ ¼åæè´¨ï¼
RLAPI Model LoadModel(const char *fileName);
// ä»çæçç½æ ¼å è½½æ¨¡åï¼é»è®¤æè´¨ï¼
RLAPI Model LoadModelFromMesh(Mesh mesh);
// æ£æ¥æ¨¡åæ¯å¦ææï¼å·²å è½½å°GPUï¼VAO/VBOï¼
RLAPI bool IsModelValid(Model model);
// ä»åå­ï¼RAMå/æVRAMï¼å¸è½½æ¨¡åï¼åæ¬ç½æ ¼ï¼
RLAPI void UnloadModel(Model model);
// è®¡ç®æ¨¡åçè¾¹çæ¡éå¶ï¼èèææç½æ ¼ï¼
RLAPI BoundingBox GetModelBoundingBox(Model model);

// æ¨¡åç»å¶å½æ°
// ç»å¶ä¸ä¸ªæ¨¡åï¼å¦æè®¾ç½®äºçº¹çï¼
RLAPI void DrawModel(Model model, Vector3 position, float scale, Color tint);
// ç¨æ©å±åæ°ç»å¶ä¸ä¸ªæ¨¡å
RLAPI void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint);
// ç»å¶æ¨¡åççº¿æ¡ï¼å¦æè®¾ç½®äºçº¹çï¼
RLAPI void DrawModelWires(Model model, Vector3 position, float scale, Color tint);
// ç¨æ©å±åæ°ç»å¶æ¨¡åççº¿æ¡ï¼å¦æè®¾ç½®äºçº¹çï¼
RLAPI void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint);
// å°æ¨¡åç»å¶ä¸ºç¹
RLAPI void DrawModelPoints(Model model, Vector3 position, float scale, Color tint);
// ç¨æ©å±åæ°å°æ¨¡åç»å¶ä¸ºç¹
RLAPI void DrawModelPointsEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint);
// ç»å¶è¾¹çæ¡ï¼çº¿æ¡ï¼
RLAPI void DrawBoundingBox(BoundingBox box, Color color);
// ç»å¶ä¸ä¸ªå¹¿åççº¹ç
RLAPI void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float scale, Color tint);
// ç»å¶ç±æºç©å½¢å®ä¹çå¹¿åççº¹ç
RLAPI void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint);
// ç»å¶ç±æºç©å½¢åæè½¬å®ä¹çå¹¿åççº¹ç
RLAPI void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint);

// ç½æ ¼ç®¡çå½æ°
// å°ç½æ ¼é¡¶ç¹æ°æ®ä¸ä¼ å°GPUå¹¶æä¾VAO/VBO ID
RLAPI void UploadMesh(Mesh *mesh, bool dynamic);
// æ´æ°GPUä¸­ç¹å®ç¼å²åºç´¢å¼çç½æ ¼é¡¶ç¹æ°æ®
RLAPI void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset);
// ä»CPUåGPUå¸è½½ç½æ ¼æ°æ®
RLAPI void UnloadMesh(Mesh mesh);
// ç¨æè´¨ååæ¢ç»å¶ä¸ä¸ª3Dç½æ ¼
RLAPI void DrawMesh(Mesh mesh, Material material, Matrix transform);
// ç¨æè´¨åä¸åçåæ¢ç»å¶å¤ä¸ªç½æ ¼å®ä¾
RLAPI void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances);
// è®¡ç®ç½æ ¼çè¾¹çæ¡éå¶
RLAPI BoundingBox GetMeshBoundingBox(Mesh mesh);
// è®¡ç®ç½æ ¼çåçº¿
RLAPI void GenMeshTangents(Mesh *mesh);
// å°ç½æ ¼æ°æ®å¯¼åºå°æä»¶ï¼æåè¿åtrue
RLAPI bool ExportMesh(Mesh mesh, const char *fileName);
// å°ç½æ ¼å¯¼åºä¸ºå®ä¹å¤ä¸ªé¡¶ç¹å±æ§æ°ç»çä»£ç æä»¶ï¼.hï¼
RLAPI bool ExportMeshAsCode(Mesh mesh, const char *fileName);

// ç½æ ¼çæå½æ°
// çæå¤è¾¹å½¢ç½æ ¼
RLAPI Mesh GenMeshPoly(int sides, float radius);
// çæå¹³é¢ç½æ ¼ï¼å¸¦æç»åï¼
RLAPI Mesh GenMeshPlane(float width, float length, int resX, int resZ);
// çæé¿æ¹ä½ç½æ ¼
RLAPI Mesh GenMeshCube(float width, float height, float length);
// çæçä½ç½æ ¼ï¼æ åçä½ï¼
RLAPI Mesh GenMeshSphere(float radius, int rings, int slices);
// çæåçä½ç½æ ¼ï¼æ åºé¨çå­ï¼
RLAPI Mesh GenMeshHemiSphere(float radius, int rings, int slices);
// çæåæ±ä½ç½æ ¼
RLAPI Mesh GenMeshCylinder(float radius, float height, int slices);
// çæåé¥/æ£±é¥ç½æ ¼
RLAPI Mesh GenMeshCone(float radius, float height, int slices);
// çæåç¯ä½ç½æ ¼
RLAPI Mesh GenMeshTorus(float radius, float size, int radSeg, int sides);
// çæä¸å¶ç»ç½æ ¼
RLAPI Mesh GenMeshKnot(float radius, float size, int radSeg, int sides);
// æ ¹æ®å¾åæ°æ®çæé«åº¦å¾ç½æ ¼
RLAPI Mesh GenMeshHeightmap(Image heightmap, Vector3 size);
// æ ¹æ®å¾åæ°æ®çæåºäºç«æ¹ä½çå°å¾ç½æ ¼
RLAPI Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize);

// æè´¨å è½½/å¸è½½å½æ°
// ä»æ¨¡åæä»¶å è½½æè´¨
RLAPI Material *LoadMaterials(const char *fileName, int *materialCount);
// å è½½é»è®¤æè´¨ï¼æ¯æï¼æ¼«åå°ãéé¢åå°ãæ³çº¿è´´å¾ï¼
RLAPI Material LoadMaterialDefault(void);
// æ£æ¥æè´¨æ¯å¦ææï¼å·²åéçè²å¨ï¼è´´å¾çº¹çå·²å è½½å°GPUï¼
RLAPI bool IsMaterialValid(Material material);
// ä»GPUåå­ï¼VRAMï¼å¸è½½æè´¨
RLAPI void UnloadMaterial(Material material);
// ä¸ºæè´¨è´´å¾ç±»åè®¾ç½®çº¹çï¼MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...ï¼
RLAPI void SetMaterialTexture(Material *material, int mapType, Texture2D texture);
// ä¸ºç½æ ¼è®¾ç½®æè´¨
RLAPI void SetModelMeshMaterial(Model *model, int meshId, int materialId);

// æ¨¡åå¨ç»å è½½/å¸è½½å½æ°
// ä»æä»¶å è½½æ¨¡åå¨ç»
RLAPI ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount);
// æ´æ°æ¨¡åå¨ç»å§¿å¿ï¼CPUï¼
RLAPI void UpdateModelAnimation(Model model, ModelAnimation anim, int frame);
// æ´æ°æ¨¡åå¨ç»ç½æ ¼éª¨éª¼ç©éµï¼GPUèç®ï¼
RLAPI void UpdateModelAnimationBones(Model model, ModelAnimation anim, int frame);
// å¸è½½å¨ç»æ°æ®
RLAPI void UnloadModelAnimation(ModelAnimation anim);
// å¸è½½å¨ç»æ°ç»æ°æ®
RLAPI void UnloadModelAnimations(ModelAnimation *animations, int animCount);
// æ£æ¥æ¨¡åå¨ç»éª¨éª¼æ¯å¦å¹é
RLAPI bool IsModelAnimationValid(Model model, ModelAnimation anim);

// ç¢°ææ£æµå½æ°
// æ£æ¥ä¸¤ä¸ªçä½ä¹é´çç¢°æ
RLAPI bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2);
// æ£æ¥ä¸¤ä¸ªè¾¹çæ¡ä¹é´çç¢°æ
RLAPI bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2);
// æ£æ¥è¾¹çæ¡åçä½ä¹é´çç¢°æ
RLAPI bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius);
// è·åå°çº¿åçä½ä¹é´çç¢°æä¿¡æ¯
RLAPI RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius);
// è·åå°çº¿åè¾¹çæ¡ä¹é´çç¢°æä¿¡æ¯
RLAPI RayCollision GetRayCollisionBox(Ray ray, BoundingBox box);
// è·åå°çº¿åç½æ ¼ä¹é´çç¢°æä¿¡æ¯
RLAPI RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform);
// è·åå°çº¿åä¸è§å½¢ä¹é´çç¢°æä¿¡æ¯
RLAPI RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3);
// è·åå°çº¿ååè¾¹å½¢ä¹é´çç¢°æä¿¡æ¯
RLAPI RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4);

//------------------------------------------------------------------------------------
// é³é¢å è½½åæ­æ¾å½æ° (æ¨¡å: é³é¢)
//------------------------------------------------------------------------------------
// é³é¢åè°å½æ°æéç±»åå®ä¹ï¼ç¨äºå¤çé³é¢æ°æ®
typedef void (*AudioCallback)(void *bufferData, unsigned int frames);

// é³é¢è®¾å¤ç®¡çå½æ°
RLAPI void InitAudioDevice(void);                                     // åå§åé³é¢è®¾å¤åä¸ä¸æ
RLAPI void CloseAudioDevice(void);                                    // å³é­é³é¢è®¾å¤åä¸ä¸æ
RLAPI bool IsAudioDeviceReady(void);                                  // æ£æ¥é³é¢è®¾å¤æ¯å¦å·²æååå§å
RLAPI void SetMasterVolume(float volume);                             // è®¾ç½®ä¸»é³é (çå¬å¨)
RLAPI float GetMasterVolume(void);                                    // è·åä¸»é³é (çå¬å¨)

// æ³¢å½¢/å£°é³å è½½/å¸è½½å½æ°
RLAPI Wave LoadWave(const char *fileName);                            // ä»æä»¶å è½½æ³¢å½¢æ°æ®
RLAPI Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize); // ä»åå­ç¼å²åºå è½½æ³¢å½¢ï¼fileType ææä»¶æ©å±åï¼ä¾å¦: '.wav'
RLAPI bool IsWaveValid(Wave wave);                                    // æ£æ¥æ³¢å½¢æ°æ®æ¯å¦ææ (æ°æ®å·²å è½½ä¸åæ°æ­£ç¡®)
RLAPI Sound LoadSound(const char *fileName);                          // ä»æä»¶å è½½å£°é³
RLAPI Sound LoadSoundFromWave(Wave wave);                             // ä»æ³¢å½¢æ°æ®å è½½å£°é³
RLAPI Sound LoadSoundAlias(Sound source);                             // åå»ºä¸ä¸ªæ°çå£°é³ï¼ä¸æºå£°é³å±äº«ç¸åçéæ ·æ°æ®ï¼ä¸æ¥æå£°é³æ°æ®
RLAPI bool IsSoundValid(Sound sound);                                 // æ£æ¥å£°é³æ¯å¦ææ (æ°æ®å·²å è½½ä¸ç¼å²åºå·²åå§å)
RLAPI void UpdateSound(Sound sound, const void *data, int sampleCount); // ç¨æ°æ°æ®æ´æ°å£°é³ç¼å²åº
RLAPI void UnloadWave(Wave wave);                                     // å¸è½½æ³¢å½¢æ°æ®
RLAPI void UnloadSound(Sound sound);                                  // å¸è½½å£°é³
RLAPI void UnloadSoundAlias(Sound alias);                             // å¸è½½å£°é³å«å (ä¸éæ¾éæ ·æ°æ®)
RLAPI bool ExportWave(Wave wave, const char *fileName);               // å°æ³¢å½¢æ°æ®å¯¼åºå°æä»¶ï¼æåè¿å true
RLAPI bool ExportWaveAsCode(Wave wave, const char *fileName);         // å°æ³¢å½¢éæ ·æ°æ®å¯¼åºä¸ºä»£ç æä»¶ (.h)ï¼æåè¿å true

// æ³¢å½¢/å£°é³ç®¡çå½æ°
RLAPI void PlaySound(Sound sound);                                    // æ­æ¾å£°é³
RLAPI void StopSound(Sound sound);                                    // åæ­¢æ­æ¾å£°é³
RLAPI void PauseSound(Sound sound);                                   // æåå£°é³
RLAPI void ResumeSound(Sound sound);                                  // æ¢å¤æåçå£°é³
RLAPI bool IsSoundPlaying(Sound sound);                               // æ£æ¥å£°é³æ¯å¦æ­£å¨æ­æ¾
RLAPI void SetSoundVolume(Sound sound, float volume);                 // è®¾ç½®å£°é³çé³é (1.0 ä¸ºæå¤§çº§å«)
RLAPI void SetSoundPitch(Sound sound, float pitch);                   // è®¾ç½®å£°é³çé³è° (1.0 ä¸ºåºç¡çº§å«)
RLAPI void SetSoundPan(Sound sound, float pan);                       // è®¾ç½®å£°é³çå£°å (0.5 ä¸ºä¸­å¿)
RLAPI Wave WaveCopy(Wave wave);                                       // å°æ³¢å½¢å¤å¶å°ä¸ä¸ªæ°çæ³¢å½¢
RLAPI void WaveCrop(Wave *wave, int initFrame, int finalFrame);       // å°æ³¢å½¢è£åªå°å®ä¹çå¸§èå´
RLAPI void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels); // å°æ³¢å½¢æ°æ®è½¬æ¢ä¸ºæéæ ¼å¼
RLAPI float *LoadWaveSamples(Wave wave);                              // ä»æ³¢å½¢å è½½éæ ·æ°æ®ä½ä¸º 32 ä½æµ®ç¹æ°æ®æ°ç»
RLAPI void UnloadWaveSamples(float *samples);                         // å¸è½½ä½¿ç¨ LoadWaveSamples() å è½½çéæ ·æ°æ®

// é³ä¹ç®¡çå½æ°
RLAPI Music LoadMusicStream(const char *fileName);                    // ä»æä»¶å è½½é³ä¹æµ
RLAPI Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize); // ä»æ°æ®å è½½é³ä¹æµ
RLAPI bool IsMusicValid(Music music);                                 // æ£æ¥é³ä¹æµæ¯å¦ææ (ä¸ä¸æåç¼å²åºå·²åå§å)
RLAPI void UnloadMusicStream(Music music);                            // å¸è½½é³ä¹æµ
RLAPI void PlayMusicStream(Music music);                              // å¼å§æ­æ¾é³ä¹
RLAPI bool IsMusicStreamPlaying(Music music);                         // æ£æ¥é³ä¹æ¯å¦æ­£å¨æ­æ¾
RLAPI void UpdateMusicStream(Music music);                            // æ´æ°é³ä¹æµçç¼å²åº
RLAPI void StopMusicStream(Music music);                              // åæ­¢æ­æ¾é³ä¹
RLAPI void PauseMusicStream(Music music);                             // æåæ­æ¾é³ä¹
RLAPI void ResumeMusicStream(Music music);                            // æ¢å¤æåçé³ä¹æ­æ¾
RLAPI void SeekMusicStream(Music music, float position);              // å°é³ä¹å®ä½å°æå®ä½ç½® (ä»¥ç§ä¸ºåä½)
RLAPI void SetMusicVolume(Music music, float volume);                 // è®¾ç½®é³ä¹çé³é (1.0 ä¸ºæå¤§çº§å«)
RLAPI void SetMusicPitch(Music music, float pitch);                   // è®¾ç½®é³ä¹çé³è° (1.0 ä¸ºåºç¡çº§å«)
RLAPI void SetMusicPan(Music music, float pan);                       // è®¾ç½®é³ä¹çå£°å (0.5 ä¸ºä¸­å¿)
RLAPI float GetMusicTimeLength(Music music);                          // è·åé³ä¹çæ»æ¶é¿ (ä»¥ç§ä¸ºåä½)
RLAPI float GetMusicTimePlayed(Music music);                          // è·åå½åé³ä¹å·²æ­æ¾çæ¶é¿ (ä»¥ç§ä¸ºåä½)

// é³é¢æµç®¡çå½æ°
RLAPI AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels); // å è½½é³é¢æµ (ç¨äºæµå¼ä¼ è¾åå§é³é¢ PCM æ°æ®)
RLAPI bool IsAudioStreamValid(AudioStream stream);                    // æ£æ¥é³é¢æµæ¯å¦ææ (ç¼å²åºå·²åå§å)
RLAPI void UnloadAudioStream(AudioStream stream);                     // å¸è½½é³é¢æµå¹¶éæ¾åå­
RLAPI void UpdateAudioStream(AudioStream stream, const void *data, int frameCount); // ç¨æ°æ®æ´æ°é³é¢æµç¼å²åº
RLAPI bool IsAudioStreamProcessed(AudioStream stream);                // æ£æ¥æ¯å¦æé³é¢æµç¼å²åºéè¦éæ°å¡«å
RLAPI void PlayAudioStream(AudioStream stream);                       // æ­æ¾é³é¢æµ
RLAPI void PauseAudioStream(AudioStream stream);                      // æåé³é¢æµ
RLAPI void ResumeAudioStream(AudioStream stream);                     // æ¢å¤é³é¢æµ
RLAPI bool IsAudioStreamPlaying(AudioStream stream);                  // æ£æ¥é³é¢æµæ¯å¦æ­£å¨æ­æ¾
RLAPI void StopAudioStream(AudioStream stream);                       // åæ­¢é³é¢æµ
RLAPI void SetAudioStreamVolume(AudioStream stream, float volume);    // è®¾ç½®é³é¢æµçé³é (1.0 ä¸ºæå¤§çº§å«)
RLAPI void SetAudioStreamPitch(AudioStream stream, float pitch);      // è®¾ç½®é³é¢æµçé³è° (1.0 ä¸ºåºç¡çº§å«)
RLAPI void SetAudioStreamPan(AudioStream stream, float pan);          // è®¾ç½®é³é¢æµçå£°å (0.5 ä¸ºä¸­å¿)
RLAPI void SetAudioStreamBufferSizeDefault(int size);                 // è®¾ç½®æ°é³é¢æµçé»è®¤ç¼å²åºå¤§å°
RLAPI void SetAudioStreamCallback(AudioStream stream, AudioCallback callback); // é³é¢çº¿ç¨åè°ï¼ç¨äºè¯·æ±æ°æ°æ®

RLAPI void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor); // å°é³é¢æµå¤çå¨éå å°æµï¼æ¥æ¶çæ ·æ¬ä¸º 'float' ç±»å
RLAPI void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor); // ä»æµä¸­åç¦»é³é¢æµå¤çå¨

RLAPI void AttachAudioMixedProcessor(AudioCallback processor); // å°é³é¢æµå¤çå¨éå å°æ´ä¸ªé³é¢ç®¡éï¼æ¥æ¶çæ ·æ¬ä¸º 'float' ç±»å
RLAPI void DetachAudioMixedProcessor(AudioCallback processor); // ä»æ´ä¸ªé³é¢ç®¡éä¸­åç¦»é³é¢æµå¤çå¨
#if defined(__cplusplus)
}
#endif

#endif // RAYLIB_H
